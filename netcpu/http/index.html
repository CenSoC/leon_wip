<!doctype html>
<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
<!--
Written and contributed by Leonid Zadorin at the Centre for the Study of Choice
(CenSoC), the University of Technology Sydney (UTS).

Copyright (c) 2012 The University of Technology Sydney (UTS), Australia
<www.uts.edu.au>

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.
3. All products which use or are derived from this software must display the
following acknowledgement:
  This product includes software developed by the Centre for the Study of
  Choice (CenSoC) at The University of Technology Sydney (UTS) and its
  contributors.
4. Neither the name of The University of Technology Sydney (UTS) nor the names
of the Centre for the Study of Choice (CenSoC) and contributors may be used to
endorse or promote products which use or are derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE CENTRE FOR THE STUDY OF CHOICE (CENSOC) AT THE
UNIVERSITY OF TECHNOLOGY SYDNEY (UTS) AND CONTRIBUTORS ``AS IS'' AND ANY 
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE CENTRE FOR THE STUDY OF CHOICE (CENSOC) OR
THE UNIVERSITY OF TECHNOLOGY SYDNEY (UTS) OR CONTRIBUTORS BE LIABLE FOR ANY 
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
-->

<!--
<meta name="viewport" content="width=device-width">
-->
<meta name="viewport" content="width=390px">

<title>WebNetCPU</title>

<!-- style { -->

<link href='http://fonts.googleapis.com/css?family=Abel|Source+Sans+Pro|Arimo&subset=latin-ext' rel='stylesheet' type='text/css'>

<style>

li {
	padding : 0.3em;
}

#overflowish {
	overflow : auto;
	-webkit-overflow-scrolling : touch;
	/* min-width : 320px; */
}

div.waiting_animation {
	text-align:center;
}

.debug_log_to_server {
	color: grey;
	font-size:10pt;
	font-family: mono;
	font-style:normal;
}

.active_task_meta_text {
	color: darkred;
	font-size:10pt;
	font-style: italic;
	padding : 0em;
	white-space: pre-wrap;
}

pre {
	white-space: pre-wrap;
}

.debug_log_from_server {
	background-color: yellow;
	font-size:12pt;
	white-space: pre-wrap;
	border-width : 0px;
}

div.beta {
	background-color: yellow;
	font-size:15pt;
	text-align:center;
	font-style:italic;
	padding : 0.777em;
}

div.loading_please_wait {
	background-color: yellow;
	font-size:48pt;
	text-align:center;
}

td.incomplete_value {
	background-color: #ffff77;
	color: black;
}

td.dataset_example_respondent_1 {
	background-color: #ffaaaa;
	color: black;
	border-left: 0;
	border-right: 0;
}
td.dataset_example_respondent_2 {
	background-color: #ff7777;
	color: black;
	border-left: 0;
	border-right: 0;
}

td.dataset_example_choiceset_1 {
	background-color: #ffffaa;
	color: black;
	border-left: 0;
	border-right: 0;
}
td.dataset_example_choiceset_2 {
	background-color: #ffff88;
	color: black;
	border-left: 0;
	border-right: 0;
}
td.dataset_example_choiceset_3 {
	background-color: #ffff55;
	color: black;
	border-left: 0;
	border-right: 0;
}

td.dataset_example_alternative_1 {
	background-color: #cffff8;
	color: black;
	border-left: 0;
	border-right: 0;
}
td.dataset_example_alternative_2 {
	background-color: #beeff7;
	color: black;
	border-left: 0;
	border-right: 0;
}
td.dataset_example_alternative_3 {
	background-color: #addfe6;
	color: black;
	border-left: 0;
	border-right: 0;
}
td.dataset_example_alternative_4 {
	background-color: #9cced5;
	color: black;
	border-left: 0;
	border-right: 0;
}

td.incomplete_normalised_value {
	background-color: white;
	color: black;
}

td.normalised_value {
	background-color: green;
	color: white;
}

* {
	font-family: 'Source Sans Pro', Verdana, Ubuntu, 'Liberation Sans', sans;
	font-size:12pt;
}

/* to 'preload(ish)' the font exclusive to html canvas... (when main font shall suffice in the html canvas drawing context with support for unicode subscripts, then delete this thing altogether). */
.hack_1 {
	color: #eeeeff; 
  font-family: Arimo;
}

body {
	background-color: #eeeeff;
}

div, p, ul, li {
	font-size: inherit;
}

label, input[type='checkbox'], button {
	cursor: pointer;
}

.extra_option_text {
	font-size:11pt;
}

.coefficients_not_ready, .task_order_column, .hinting_text {
	font-size:10pt;
	font-style:italic;
}

.task_order_column {
	background-color: #efefff;
}

.task_order_column_alt {
	background-color: #e1e1f2;
}

.coefficients_not_ready {
	background-color: #ddddee;
	border-top: 0;
	border-bottom-color: black;
}

.active_task_label {
	background-color: red;
	color: white;
	font-weight: bold;
}
.pending_task_label {
	background-color: yellow;
	color: black;
}
.complete_task_label {
	background-color: lightgreen;
	color: black;
}

.help_content {
	visibility:hidden;
}

.help_content_visible {
	visibility:visible;
}

.help_content, .help_content_visible {
	font-size: 11pt;
}

.help_content_title {
	font-size:13pt;
}

.help_content_title, .help_content_fieldname {
	color: purple;
	font-style: italic;
}

button, select {
	width: 100%;
	font-size:12pt;
	border-radius: 0.3em;
	/* box-shadow: inset 0px 15px 5px -5px rgba(0,0,0,.3); */
	box-shadow: 1px 2px 3px -1px rgba(0,0,0,0.3);
	background: #ccbbdd;
	background: linear-gradient(to bottom,  #ececfd,  #ccbbdd);
}

button {
	color: #111111;
	margin-left: 0px;
	margin-right: 0px;
	margin-bottom: 2px;
	margin-top: 2px;
}

td.unspecified_csv {
	text-align:right;
}

td.respondent_csv {
	text-align:right;
	background-color: salmon;
}

td.observation_csv {
	text-align:right;
	background-color: yellow;
}

td.alternative_csv {
	text-align:right;
	background-color: lightblue;
}

td.attribute_csv {
	text-align:right;
	background-color: lightgreen;
}

td.choice_csv {
	text-align:right;
	background-color: orange;
}

td.centered_td {
	text-align:center;
}

.help_content_title, td.page_title_td, div.beta {
	font-family: 'Abel', 'Source Sans Pro', Verdana, Ubuntu, 'Liberation Sans', serif;
}

button, div.beta, .debug_log_from_server, .help_content_fieldname, .complete_task_label {
	text-shadow: 4px 4px 4px #aaa;
}

td.page_title_td {
	text-shadow: 5px 5px 5px #000;
}

td.page_title_td {
	text-align:center;
	color: white;
	background-color: purple;
	font-weight: bold;
	/* font-style:italic; */
}

td.left_td {
	text-align:left;
}

.auto_table {
	width : auto;
	margin-left: 0;
	margin-right: auto;
}

.centered_table {
	width : auto;
	margin-left: auto;
	margin-right: auto;
}

.full_width {
	width : 100%; 
	padding : 0.57em;
}

.contextmenu {
	/* border-style : solid;
	border-width : 1px; */
	/* border-color : red; */
	padding : 3px;
	background : yellow;
	position : absolute;
	display : block;
	width : auto;
}

.coeff_metadata {
}

.coeff_metadata_selected {
	background-color: yellow;
}

input {
	padding: 1pt;
	/* background-color: #ddddee; */
	background-color: white;
	text-align:right;
}

input.short_description {
	text-align:left;
	width: 90%;
}

input:disabled {
	background-color: #dfdfdf;
}

input.freeform_cli {
	padding: 1pt;
	text-align:left;
}

.freeform_cli_example {
	background-color: yellow;
	color: black;
}

table, th, td {
	border-collapse: collapse;
	text-align:left;
	padding: 3pt;
	border: 1pt solid #bbbbcc;
	font-style:normal;
}

.terrain_elevation_value {
	font-style:normal;
	font-size:11pt;
	color: black;
}


/*
table {
	width: 100%;
}
input.number {
	text-align:center;
	width: 50%;
	width: 10em;
	min: -100;
	max: 100;
}
*/

</style>
<!-- } -->

<!-- code { -->

<script type="text/javascript" src="third_party/zip/zip.js"></script>

<script type="text/javascript" src="index_utils.js"></script>   

<script type="text/javascript">

var two_pi = Math.PI * 2;
var half_pi = Math.PI / 2;

var request_animation_frame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
var cancel_animation_frame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame;

// TODO -- later on will have a whole array of possible servers whilst being able to determine which one to use (ala partial remedy/mitigation w.r.t. denial of service attacks where load-balancing is also actively done at the client/browser end)
//var server_at = "https://localhost:8055/";
//var server_at = "https://localhost:8081/";
var server_at = "https://webnetcpu.zapto.org:443/"
//var server_at = "https://netcpu2.zapto.org:443/"
//var server_at = "https://www2.netcpu.pagekite.me:443/"

// keeping it 'global' -- dont want to have too many sprinkled across the app...
var worker = new Worker("index_worker.js");

function cli_coefficient_range_metadata_type(row_index, pid)
{
	function common_context_menu_1(x, y) 
	{
		batch_fill_context_menu.set_coordinates(x, y);
		batch_fill_context_menu.fill_right_row_button.style.display = "none";
		batch_fill_context_menu.fill_to_corner_button.style.display = "none";
		batch_fill_context_menu.fill_down_row_button.onclick = function () {
			pid.fill_down_row(row_index);
			batch_fill_context_menu.hide();
		}
		batch_fill_context_menu.show();
	}

	//{ from control
	this.from = document.createElement("input");
	this.from.title = "Right-click for quick-fill menu...";
	//this.from.type = "number";
	this.from.className = "coeff_metadata";
	this.from.size = 5;
	this.from.oncontextmenu = function(event)
	{
		batch_fill_context_menu.cell_gui = this;
		batch_fill_context_menu.fill_down_column_button.onclick = function () {
			pid.fill_down_column_from(row_index);
			batch_fill_context_menu.hide();
		}
		common_context_menu_1(event.clientX, event.clientY);
		return false;
	}
	//}

	//{ to control
	this.to = document.createElement("input");
	//this.to.type = "number";
	this.to.title = "Right-click for quick-fill menu...";
	this.to.className = "coeff_metadata";
	this.to.size = 5;
	this.to.oncontextmenu = function(event)
	{
		batch_fill_context_menu.cell_gui = this;
		batch_fill_context_menu.fill_down_column_button.onclick = function () {
			pid.fill_down_column_to(row_index);
			pid.batch_fill_context_menu.hide();
		}
		common_context_menu_1(event.clientX, event.clientY);
		return false;
	}
	//}

	//{ minstep control
	this.minstep = document.createElement("input");
	//this.minstep.type = "number";
	this.minstep.title = "Right-click for quick-fill menu...";
	this.minstep.className = "coeff_metadata";
	this.minstep.size = 5;
	this.minstep.oncontextmenu = function(event)
	{
		batch_fill_context_menu.cell_gui = this;
		batch_fill_context_menu.fill_down_column_button.onclick = function () {
			pid.fill_down_column_minstep(row_index);
			batch_fill_context_menu.hide();
		}
		common_context_menu_1(event.clientX, event.clientY);
		return false;
	}
	//}

	this.validate = function()
	{
		var from_value = parseFloat(this.from.value); 
		var to_value = parseFloat(this.to.value);
		var minstep_value = parseFloat(this.minstep.value);
		if (isNaN(from_value) == true ||
				isNaN(to_value) == true ||
				isNaN(minstep_value) == true ||
				from_value >= to_value || minstep_value <= 0 ||
				!this.grid_resolutions.length) {
			alert("Initial complexity table's row(=" + (row_index + 1) + ") does not have correct values.");
			return false;
		}
		for (var i = 0; i != this.grid_resolutions.length; ++i) {
			var value = parseInt(this.grid_resolutions[i].value);
			if (isNaN(value) == true || value < 2) {
				alert("Initial complexity table's row(=" + (row_index + 1) + ") 'Gridsteps for x-coefficients-@once modulations' column(=" + (i + 1) + ") does not have correct value.");
				return false;
			}
		}
		return true;
	}

	this.grid_resolutions = [];
	this.allocate = function(x) 
	{
		this.grid_resolutions.length = x;
		for (var i = 0; i != this.grid_resolutions.length; ++i) {
			var tmp = document.createElement("input");
			tmp.column_index = i;
			tmp.className = "coeff_metadata";
			tmp.size = 5;
			tmp.title = "Right-click for quick-fill menu...";
			tmp.oncontextmenu = function(event)
			{
				var column_index = this.column_index;
				batch_fill_context_menu.cell_gui = this;
				batch_fill_context_menu.set_coordinates(event.clientX, event.clientY);
				batch_fill_context_menu.fill_down_column_button.onclick = function () {
					pid.fill_down_column_grid_resolutions(row_index, column_index);
					batch_fill_context_menu.hide();
				}
				batch_fill_context_menu.fill_down_row_button.onclick = function () {
					pid.fill_down_row(row_index);
					batch_fill_context_menu.hide();
				}
				batch_fill_context_menu.fill_right_row_button.style.display = "block";
				batch_fill_context_menu.fill_right_row_button.onclick = function () {
					pid.fill_right_row_grid_resolutions(row_index, column_index);
					batch_fill_context_menu.hide();
				}
				batch_fill_context_menu.fill_to_corner_button.style.display = "block";
				batch_fill_context_menu.fill_to_corner_button.onclick = function () {
					pid.fill_to_corner(row_index, column_index);
					batch_fill_context_menu.hide();
				}
				batch_fill_context_menu.show();
				return false;
			}
			this.grid_resolutions[i] = tmp;
		}
	}
}

function cli_coefficient_range_metadata_x_type(row_index, pid)
{
	function common_context_menu_1(x, y) 
	{
		batch_fill_context_menu.set_coordinates(x, y);
		batch_fill_context_menu.fill_right_row_button.style.display = "none";
		batch_fill_context_menu.fill_to_corner_button.style.display = "none";

		batch_fill_context_menu.fill_down_row_button.onclick = function () {
			pid.fill_down_row(row_index);
			batch_fill_context_menu.hide();
		}

		batch_fill_context_menu.show();
	}

	//{ threshold control
	this.threshold = document.createElement("input");
	this.threshold.title = "Right-click for quick-fill menu...";
	//this.threshold.type = "number";
	this.threshold.className = "coeff_metadata";
	this.threshold.size = 5;
	this.threshold.oncontextmenu = function(event)
	{
		batch_fill_context_menu.cell_gui = this;
		batch_fill_context_menu.fill_down_column_button.onclick = function () {
			pid.fill_down_column_threshold(row_index);
			batch_fill_context_menu.hide();
		}
		common_context_menu_1(event.clientX, event.clientY);
		return false;
	}
	//}

	this.validate = function()
	{
		var threshold_value = parseFloat(this.threshold.value); 
		if (isNaN(threshold_value) == true ||
				threshold_value <= 0 ||
				!this.grid_resolutions.length) {
			alert("Subesquent complexity table's row(=" + (row_index + 1) + ") does not have correct values.");
			return false;
		}
		for (var i = 0; i != this.grid_resolutions.length; ++i) {
			var value = parseInt(this.grid_resolutions[i].value);
			if (isNaN(value) == true || value < 2) {
				alert("One of the subsequent complexity table's row(=" + (row_index + 1) + ") 'Gridsteps for x-coefficients-@once modulations' column(=" + (i + 1) + ") does not have correct value.");
				return false;
			}
		}
		return true;
	}

	this.grid_resolutions = [];
	this.allocate = function(x) 
	{
		this.grid_resolutions.length = x;
		for (var i = 0; i != x; ++i) {
			var tmp = document.createElement("input");
			tmp.column_index = i;
			tmp.className = "coeff_metadata";
			tmp.title = "Right-click for quick-fill menu...";
			tmp.size = 5;
			// todo -- common code with non _x inital complexity bits...
			tmp.oncontextmenu = function(event)
			{
				var column_index = this.column_index;
				batch_fill_context_menu.cell_gui = this;
				batch_fill_context_menu.set_coordinates(event.clientX, event.clientY);
				batch_fill_context_menu.fill_down_column_button.onclick = function () {
					pid.fill_down_column_grid_resolutions(row_index, column_index);
					batch_fill_context_menu.hide();
				}
				batch_fill_context_menu.fill_down_row_button.onclick = function () {
					pid.fill_down_row(row_index);
					batch_fill_context_menu.hide();
				}
				batch_fill_context_menu.fill_right_row_button.style.display = "block";
				batch_fill_context_menu.fill_right_row_button.onclick = function () {
					pid.fill_right_row_grid_resolutions(row_index, column_index);
					batch_fill_context_menu.hide();
				}
				batch_fill_context_menu.fill_to_corner_button.style.display = "block";
				batch_fill_context_menu.fill_to_corner_button.onclick = function () {
					pid.fill_to_corner(row_index, column_index);
					batch_fill_context_menu.hide();
				}
				batch_fill_context_menu.show();
				return false;
			}
			this.grid_resolutions[i] = tmp;
		}
	}
}

function subsequent_complexity_type(pid)
{
	var subsequent_complexity_type_this = this;
	var gui_deco = document.createElement("div");
	this.coeffs_atonce = document.createElement("input");
	//this.coeffs_atonce.type = "number";
	this.coeffs_atonce.size = 5;
	this.coeffs_atonce.value = 0;
	this.coeffs_atonce.onchange = function () {
		var value = parseInt(this.value);
		if (isNaN(value) == true || value < 1)
			value = 0;
		this.value = value;
		subsequent_complexity_type_this.populate(gui);
	};

	gui_deco.appendChild(document.createElement("hr"));
	gui_deco.appendChild(document.createTextNode("Additional x-coefficients-@-once complexity:"));
	gui_deco.appendChild(this.coeffs_atonce);
	gui_deco.appendChild(document.createElement("p"));

	this.cli_coefficient_range_metadata_x = [];
	var table = document.createElement("table");

	var gui = null;

	this.populate = function(new_gui) 
	{
		if (new_gui !== gui)
			new_gui.appendChild(gui_deco);

		var new_table = document.createElement("table");
		new_table.className = "auto_table";
		var coeffs_at_once_value = parseInt(this.coeffs_atonce.value);
		if (Object.keys(pid.attributes).length && pid.coefficients.length && coeffs_at_once_value > 0) {
			var tr = document.createElement("tr");
			var td = document.createElement("td");
			td.className = "centered_td";
			td.rowSpan = 2;
			td.appendChild(document.createTextNode("Semantics"));
			tr.appendChild(td);

			td = document.createElement("td");
			td.className = "centered_td";
			td.rowSpan = 2;
			td.appendChild(document.createTextNode("Activate @range"));
			td.appendChild(document.createElement("br"));
			td.appendChild(document.createTextNode("less than"));
			tr.appendChild(td);

			td = document.createElement("td");
			td.className = "centered_td";
			td.colSpan = coeffs_at_once_value;
			td.appendChild(document.createTextNode("Gridsteps for"));
			td.appendChild(document.createElement("br"));
			td.appendChild(document.createTextNode("x-coefficients-@once modulations"));
			tr.appendChild(td);
			new_table.appendChild(tr);

			tr = document.createElement("tr");

			for (var i = 1; i <= coeffs_at_once_value; ++i) {
				td = document.createElement("td");
				td.className = "centered_td";
				td.appendChild(document.createTextNode(i + "-@once"));
				tr.appendChild(td);
			}
			new_table.appendChild(tr);

			this.cli_coefficient_range_metadata_x.length = pid.coefficients.length;
			for (var i = 0; i != pid.coefficients.length; ++i) {
				this.cli_coefficient_range_metadata_x[i] = new cli_coefficient_range_metadata_x_type(i, this);
				this.cli_coefficient_range_metadata_x[i].allocate(coeffs_at_once_value);

				tr = document.createElement("tr");

				td = document.createElement("td");
				td.className = "centered_td";
				td.innerHTML = pid.coefficients[i];
				tr.appendChild(td);

				td = document.createElement("td");
				td.className = "centered_td";
				td.appendChild(this.cli_coefficient_range_metadata_x[i].threshold);
				tr.appendChild(td);

				for (var j = 0; j != this.coeffs_atonce.value; ++j) {
					td = document.createElement("td");
					td.className = "centered_td";
					td.appendChild(this.cli_coefficient_range_metadata_x[i].grid_resolutions[j]);
					tr.appendChild(td);
				}
				new_table.appendChild(tr);
			}
		}
		if (new_gui !== gui)
			new_gui.appendChild(new_table);
		else 
			new_gui.replaceChild(new_table, table);
		table = new_table;
		gui = new_gui;
	}

	this.fill_down_row = function(x)
	{
		var source = this.cli_coefficient_range_metadata_x[x];
		for (var i = x + 1; i != this.cli_coefficient_range_metadata_x.length; ++i) {
			this.cli_coefficient_range_metadata_x[i].threshold.value = source.threshold.value;
			for (var j = 0; j != source.grid_resolutions.length; ++j)
				this.cli_coefficient_range_metadata_x[i].grid_resolutions[j].value = source.grid_resolutions[j].value;
		}
	}

	this.fill_down_column_threshold = function(x)
	{
		var value = this.cli_coefficient_range_metadata_x[x].threshold.value;
		for (var i = x + 1; i != this.cli_coefficient_range_metadata_x.length; ++i)
			this.cli_coefficient_range_metadata_x[i].threshold.value = value;
	}

	this.fill_down_column_grid_resolutions = function(x, y)
	{
		var value = this.cli_coefficient_range_metadata_x[x].grid_resolutions[y].value;
		for (var i = x + 1; i != this.cli_coefficient_range_metadata_x.length; ++i)
			this.cli_coefficient_range_metadata_x[i].grid_resolutions[y].value = value;
	}

	this.fill_right_row_grid_resolutions = function(x, y)
	{
		var value = this.cli_coefficient_range_metadata_x[x].grid_resolutions[y].value;
		for (var i = y + 1; i != this.cli_coefficient_range_metadata_x[x].grid_resolutions.length; ++i)
			this.cli_coefficient_range_metadata_x[x].grid_resolutions[i].value = value;
	}

	this.fill_to_corner = function(x, y)
	{
		var value = this.cli_coefficient_range_metadata_x[x].grid_resolutions[y].value;
		for (var j = x; j != this.cli_coefficient_range_metadata_x.length; ++j) {
			for (var i = y; i != this.cli_coefficient_range_metadata_x[j].grid_resolutions.length; ++i) {
				this.cli_coefficient_range_metadata_x[j].grid_resolutions[i].value = value;
			}
		}
	}
}

function select_csv_column_type(pid, index)
{
	var select_csv_column_type_this = this;

	this.gui = document.createElement("select");
	this.gui.className = "full_width";
	this.gui.size = 1;
	this.gui.style.minWidth = "8em";

	var tmp;

	tmp = document.createElement("option");
	tmp.value = 0;
	tmp.appendChild(document.createTextNode("Unassigned"));
	this.gui.appendChild(tmp);

	tmp = document.createElement("option");
	tmp.value = 4;
	tmp.appendChild(document.createTextNode("Attribute"));
	this.gui.appendChild(tmp);

	tmp = document.createElement("option");
	tmp.value = 1;
	tmp.appendChild(document.createTextNode("Respondent"));
	this.gui.appendChild(tmp);

	tmp = document.createElement("option");
	tmp.value = 2;
	tmp.appendChild(document.createTextNode("Choice-Set"));
	this.gui.appendChild(tmp);

	tmp = document.createElement("option");
	tmp.value = 3;
	tmp.appendChild(document.createTextNode("Alternative"));
	this.gui.appendChild(tmp);

	tmp = document.createElement("option");
	tmp.value = 5;
	tmp.appendChild(document.createTextNode("Choice"));
	this.gui.appendChild(tmp);

	function radio_button_style(x)
	{
		for (var i = 0; x && i != pid.csv_column_types.length; ++i) {
			if (pid.csv_column_types[i].gui != select_csv_column_type_this.gui && pid.csv_column_types[i].gui.value == x) {
				set_pid_csv_table_column_i("unspecified_csv", i);
				pid.csv_column_types[i].gui.value = 0;
				break;
			}
		}
	}

	function set_pid_csv_table_column(x)
	{
		set_pid_csv_table_column_i(x, index);
	}
	function set_pid_csv_table_column_i(x, index)
	{
		for (var i = 1; i !=  pid.csv_table.rows.length; ++i)
			if (pid.csv_table.rows[i].cells.length > index)
				pid.csv_table.rows[i].cells[index].className = x;
	}

	this.gui.onchange = function () {
		var switch_value = parseInt(this.value);
		switch (switch_value) {
			case 0 :
				set_pid_csv_table_column("unspecified_csv");
				break;
			case 1 :
				set_pid_csv_table_column("respondent_csv");
				break;
			case 2 :
				set_pid_csv_table_column("observation_csv");
				break;
			case 3 :
				set_pid_csv_table_column("alternative_csv");
				break;
			case 4 :
				set_pid_csv_table_column("attribute_csv");
				break;
			case 5 :
				set_pid_csv_table_column("choice_csv");
				break;
		}
		if (switch_value != 4) {
			radio_button_style(switch_value);
			if (pid.attributes[index] == true) {
				delete pid.attributes[index];
				pid.model.onchange();
			}
		} else {
			pid.attributes[index] = true;
			pid.model.onchange();
		}
	}
}

function help_content_type(title, source_id)
{
	var help_content_type_this = this;
	var help_content = document.getElementById(source_id);
	document.body.removeChild(help_content);
	help_content.className = "help_content_visible";

	this.gui = document.createElement("div");
	var title_span = document.createElement("span");
	title_span.className = "help_content_title";
	title_span.appendChild(document.createTextNode(title));
	this.gui.appendChild(title_span);
	var label = document.createElement("label");
	label.className = "help_content_title";
	label.appendChild(document.createTextNode(" (show help"));
	var checkbox = document.createElement("input");
	checkbox.type = "checkbox";
	checkbox.checked = false;
	checkbox.onchange = function ()
	{
		if (this.checked == true)
			help_content_type_this.gui.appendChild(help_content);
		else
			help_content_type_this.gui.removeChild(help_content);
	}
	label.appendChild(checkbox);
	label.appendChild(document.createTextNode(")"));
	this.gui.appendChild(label);
}

function new_task_type()
{
	var new_task_type_this = this;

	var csv_grid = [];

	var gui = document.createElement("table");
	gui.className = "centered_table";

	//{ model...
	this.model = document.createElement("select");
	this.model.className = "full_width";
	this.model.size = 1;

	var tmp = document.createElement("option");
	tmp.value = 0;
	tmp.selected = true;
	tmp.appendChild(document.createTextNode("Select computational model..."));
	this.model.appendChild(tmp);

	tmp = document.createElement("option");
	tmp.value = 1;
	tmp.appendChild(document.createTextNode("Logit"));
	// tmp.disabled = true;
	this.model.appendChild(tmp);

	tmp = document.createElement("option");
	tmp.value = 2;
	tmp.appendChild(document.createTextNode("Mixed logit"));
	this.model.appendChild(tmp);

	tmp = document.createElement("option");
	tmp.value = 3;
	tmp.appendChild(document.createTextNode("GMNL-II"));
	this.model.appendChild(tmp);

	tmp = document.createElement("option");
	tmp.value = 4;
	tmp.appendChild(document.createTextNode("Gmnl2a"));
	this.model.appendChild(tmp);

	tmp = document.createElement("option");
	tmp.value = 5;
	tmp.appendChild(document.createTextNode("Multi logit"));
	this.model.appendChild(tmp);

	this.model.onchange = function () {
		new_task_type_this.coefficients.length = 0;
		switch (parseInt(this.value)) {
			case 0:
				new_task_type_this.multi_logit_betas_sets_size_div.style.display = "none";
				repeats.disabled = true;
				draws_sets_size.disabled = true;
				break;
			case 1:
				new_task_type_this.multi_logit_betas_sets_size_div.style.display = "none";
				repeats.disabled = true;
				draws_sets_size.disabled = true;
				for (var i = 0; i != Object.keys(new_task_type_this.attributes).length; i++)
					new_task_type_this.coefficients.push("<b>&beta;</b><sub>" + (i + 1) + "</sub>");
				break;
			case 2:
				new_task_type_this.multi_logit_betas_sets_size_div.style.display = "none";
				repeats.disabled = false;
				draws_sets_size.disabled = false;
				for (var i = 0; i != Object.keys(new_task_type_this.attributes).length; i++)
					new_task_type_this.coefficients.push("<b>&beta;</b><sub>" + (i + 1) + "</sub>");
				for (var i = 0; i != Object.keys(new_task_type_this.attributes).length; i++)
					new_task_type_this.coefficients.push("<b>&sigma;</b><sub>&beta;<sub>" + (i + 1) + "</sub></sub>");
				break;
			case 3:
				new_task_type_this.multi_logit_betas_sets_size_div.style.display = "none";
				repeats.disabled = false;
				draws_sets_size.disabled = false;
				for (var i = 0; i != Object.keys(new_task_type_this.attributes).length; i++)
					new_task_type_this.coefficients.push("<b>&beta;</b><sub>" + (i + 1) + "</sub>");
				for (var i = 0; i != Object.keys(new_task_type_this.attributes).length; i++)
					new_task_type_this.coefficients.push("<b>&sigma;</b><sub>&beta;<sub>" + (i + 1) + "</sub></sub>");
				new_task_type_this.coefficients.push("&tau;");
				break;
			case 4:
				new_task_type_this.multi_logit_betas_sets_size_div.style.display = "none";
				repeats.disabled = false;
				draws_sets_size.disabled = false;
				for (var i = 0; i != Object.keys(new_task_type_this.attributes).length; i++)
					new_task_type_this.coefficients.push("<b>&beta;</b><sub>" + (i + 1) + "</sub>");
				for (var i = 0; i != Object.keys(new_task_type_this.attributes).length; i++)
					new_task_type_this.coefficients.push("<b>&sigma;</b><sub>&beta;<sub>" + (i + 1) + "</sub></sub>");
				new_task_type_this.coefficients.push("&tau;");
				new_task_type_this.coefficients.push("<i>&mu;(&Phi;)</i>");
				// new_task_type_this.coefficients.push("<i>&Phi;&#772;</i>");
				new_task_type_this.coefficients.push("&sigma;<sub><i>&Phi;</i></sub>");
				new_task_type_this.coefficients.push("&rho;<sub>&tau;<i>&Phi;</i></sub>");
				break;
			case 5:
				new_task_type_this.multi_logit_betas_sets_size_div.style.display = "block";
				repeats.disabled = draws_sets_size.disabled = true;

				var betas_sets_size = parseInt(new_task_type_this.multi_logit_betas_sets_size_input.value);
				for (var c = 0; c != betas_sets_size; ++c) {
					new_task_type_this.coefficients.push("<b>&tau;</b><sub>(" + (c + 1) + ")</sub>");
					for (var i = 0; i != Object.keys(new_task_type_this.attributes).length; i++)
						new_task_type_this.coefficients.push("<b>&beta;</b><sub>(" + (c + 1) + ')' + (i + 1) + "</sub>");
				}
				break;
		}
		populate_complexity_tables();
	}
	new_task_type_this.multi_logit_betas_sets_size_div = document.createElement("div");
	new_task_type_this.multi_logit_betas_sets_size_div.style.display = "none";
	new_task_type_this.multi_logit_betas_sets_size_input = document.createElement("input");
	new_task_type_this.multi_logit_betas_sets_size_input.type = "number";
	new_task_type_this.multi_logit_betas_sets_size_input.size = 2;
	new_task_type_this.multi_logit_betas_sets_size_input.value = 5;
	new_task_type_this.multi_logit_betas_sets_size_input.onchange = function () {
		var value = parseInt(this.value);
		if (isNaN(value) == true || value < 1) {
			alert("value must be a number and not less than 1");
			this.value = 5;
		} else
			new_task_type_this.model.onchange();
	}
	new_task_type_this.multi_logit_betas_sets_size_div.appendChild(document.createTextNode("number of classes:"));
	new_task_type_this.multi_logit_betas_sets_size_div.appendChild(new_task_type_this.multi_logit_betas_sets_size_input);
	//} ... model

	var previous_attrubtes_length = 0;
	var previous_coefficients_length = 0;
	function populate_complexity_tables() 
	{
		var table = document.createElement("table");
		table.className = "auto_table";
		if (Object.keys(new_task_type_this.attributes).length && new_task_type_this.coefficients.length && coeffs_atonce.value > 0) {
			var tr = document.createElement("tr");
			tr.appendChild(document.createElement("td"));
			var td = document.createElement("td");
			td.colSpan = 3 + coeffs_atonce.value;
			td.className = "centered_td";
			var tmp = document.createElement("span");
			tmp.className = "hinting_text";
			tmp.appendChild(document.createTextNode("(right-click (long-press on tablets) entry fields for quick-fill opnions)"));
			td.appendChild(tmp);
			tr.appendChild(td);
			table.appendChild(tr);

			tr = document.createElement("tr");
			td = document.createElement("td");
			td.className = "centered_td";
			td.rowSpan = 2;
			td.appendChild(document.createTextNode("Semantics"));
			tr.appendChild(td);

			td = document.createElement("td");
			td.className = "centered_td";
			td.colSpan = 2;
			td.appendChild(document.createTextNode("Initial exploration range"));
			tr.appendChild(td);

			td = document.createElement("td");
			td.className = "centered_td";
			td.rowSpan = 2;
			td.appendChild(document.createTextNode("Consider done"));
			td.appendChild(document.createElement("br"));
			td.appendChild(document.createTextNode("@range"));
			tr.appendChild(td);

			td = document.createElement("td");
			td.className = "centered_td";
			td.colSpan = coeffs_atonce.value;
			td.appendChild(document.createTextNode("Gridsteps for"));
			td.appendChild(document.createElement("br"));
			td.appendChild(document.createTextNode("x-coefficients-@once modulations"));
			tr.appendChild(td);

			table.appendChild(tr);

			tr = document.createElement("tr");

			/*
				 td = document.createElement("td");
				 td.appendChild(document.createTextNode("coeff"));
				 td.appendChild(document.createElement("br"));
				 td.appendChild(document.createTextNode("number"));
				 tr.appendChild(td);
			 */

			td = document.createElement("td");
			td.className = "centered_td";
			td.appendChild(document.createTextNode("from"));
			tr.appendChild(td);
			td = document.createElement("td");
			td.className = "centered_td";
			td.appendChild(document.createTextNode("to"));
			tr.appendChild(td);


			for (var i = 1; i <= coeffs_atonce.value; ++i) {
				td = document.createElement("td");
				td.className = "centered_td";
				td.appendChild(document.createTextNode(i + "-@once"));
				tr.appendChild(td);
			}
			table.appendChild(tr);

			cli_coefficient_range_metadata.length = new_task_type_this.coefficients.length;
			for (var i = 0; i != new_task_type_this.coefficients.length; ++i) {
				cli_coefficient_range_metadata[i] = new cli_coefficient_range_metadata_type(i, new_task_type_this);
				cli_coefficient_range_metadata[i].allocate(parseInt(coeffs_atonce.value));

				tr = document.createElement("tr");

				td = document.createElement("td");
				td.className = "centered_td";
				td.innerHTML = new_task_type_this.coefficients[i];
				tr.appendChild(td);

				/*
					 td = document.createElement("td");
					 td.appendChild(document.createTextNode(i + 1));
					 tr.appendChild(td);
				 */

				td = document.createElement("td");
				td.className = "centered_td";
				td.appendChild(cli_coefficient_range_metadata[i].from);
				tr.appendChild(td);

				td = document.createElement("td");
				td.appendChild(cli_coefficient_range_metadata[i].to);
				td.className = "centered_td";
				tr.appendChild(td);

				td = document.createElement("td");
				td.className = "centered_td";
				td.appendChild(cli_coefficient_range_metadata[i].minstep);
				tr.appendChild(td);

				for (var j = 0; j != coeffs_atonce.value; ++j) {
					td = document.createElement("td");
					td.className = "centered_td";
					td.appendChild(cli_coefficient_range_metadata[i].grid_resolutions[j]);
					tr.appendChild(td);
				}
				table.appendChild(tr);
			}
		}

		if (previous_attrubtes_length != Object.keys(new_task_type_this.attributes).length || previous_coefficients_length != new_task_type_this.coefficients.length) {
			previous_attrubtes_length = Object.keys(new_task_type_this.attributes).length;
			previous_coefficients_length = new_task_type_this.coefficients.length;

			var newdiv = document.createElement("div");
			newdiv.appendChild(table);
			var newdivx = document.createElement("div");
			for (var i = 0; i < subsequent_complexities_size.value; ++i)
				subsequent_complexities[i].populate(newdivx);

			newdiv.appendChild(newdivx);

			all_complexity_tables_holder.replaceChild(newdiv, initial_complexity_table_holder);
			initial_complexity_table_holder = newdiv;
			subsequent_complexity_tables_holder = newdivx;
		} else {
			initial_complexity_table_holder.replaceChild(table, initial_complexity_table);
		}
		initial_complexity_table = table;
	}

	this.csv_column_types = [];
	this.attributes = {};
	this.coefficients = [];

	var subsequent_complexities = [];
	var coeffs_atonce = document.createElement("input");
	coeffs_atonce.type = "number";
	coeffs_atonce.size = 5;
	coeffs_atonce.value = 0;
	coeffs_atonce.onchange = function () {
		var value = parseInt(this.value);
		if (isNaN(value) == true || value < 1)
			value = 0;
		this.value = value;
		populate_complexity_tables();
	};
	var cli_coefficient_range_metadata = [];
	var initial_complexity_table = document.createElement("table");

	var tr, td, tmp_tr, tmp_td; 

	tr = document.createElement("tr");
	td = document.createElement("td");
	td.className = "page_title_td";
	td.appendChild(document.createTextNode("ADDING A NEW TASK"));
	tr.appendChild(td);
	gui.appendChild(tr);

	tr = document.createElement("tr");
	td = document.createElement("td");
	var help_model_content = new help_content_type("Step 1: Choose computational model", "help_model_content");
	td.appendChild(help_model_content.gui);
	td.appendChild(this.model);
	td.appendChild(new_task_type_this.multi_logit_betas_sets_size_div);
	tr.appendChild(td);
	gui.appendChild(tr);

	tr = document.createElement("tr");
	td = document.createElement("td");

	var help_dataset_content = new help_content_type("Step 2: Choose dataset", "help_dataset_content");
	td.appendChild(help_dataset_content.gui);

	var tmp_tbl = document.createElement("table");
	tmp.className = "auto_table";
	tmp_tr = document.createElement("tr");
	tmp_td = document.createElement("td");
	tmp_td.appendChild(document.createTextNode(".CSV file:"));
	tmp_tr.appendChild(tmp_td);
	tmp_td = document.createElement("td");
	tmp_file_choice = document.createElement("input");
	tmp_file_choice.type = "file";

	tmp_td.appendChild(tmp_file_choice);
	tmp_tr.appendChild(tmp_td);
	tmp_tbl.appendChild(tmp_tr);

	tmp_tr = document.createElement("tr");
	tmp_td = document.createElement("td");
	tmp_td.appendChild(document.createTextNode("Preview rows:"));
	tmp_tr.appendChild(tmp_td);
	tmp_td = document.createElement("td");
	tmp_csv_preview_rows = document.createElement("input");
	tmp_csv_preview_rows.size = 5;
	tmp_csv_preview_rows.value = 10;
	tmp_td.appendChild(tmp_csv_preview_rows);
	tmp_tr.appendChild(tmp_td);
	tmp_tbl.appendChild(tmp_tr);

	tmp_csv_preview_rows.onchange = function()
	{
		var new_value = parseInt(this.value);
		if (isNaN(new_value) == true)
			this.value = 10;
		else if (new_value > 1000)
			this.value = 1000;
		else if (new_value < 3)
			this.value = 3;
		else
			this.value = new_value;

		if (tmp_file_choice.files.length)
			populate_csv_table(false);
	}
	function populate_csv_table(do_renew_csv_columns)
	{
		var csv_table_holder_previous_class_name = new_task_type_this.csv_table_holder.style.className;
		new_task_type_this.csv_table_holder.className = "debug_log_from_server";
		{
		var txt = document.createTextNode('');
		new_task_type_this.csv_table_holder.replaceChild(txt, new_task_type_this.csv_table);
		new_task_type_this.csv_table = txt;
		}
		worker.onmessage = function(e) {
			if (e.data.message == "progress") {
				var txt = document.createTextNode("Parsing: " + Math.min(parseInt(e.data.percent), 99) + "% done... please wait.");
				new_task_type_this.csv_table_holder.replaceChild(txt, new_task_type_this.csv_table);
				new_task_type_this.csv_table = txt;
			} else if (e.data.message == "preview_csv") {
				new_task_type_this.csv_table_holder.className = csv_table_holder_previous_class_name;
				new_task_type_this.model.onchange();
				csv_grid = e.data.csv_grid;
				var table = document.createElement("table");
				//var rows = Math.min(Math.max(csv_grid.length, 0), 10);
				var rows = csv_grid.length;
				if (rows > 0) {
					var first_row_columns = csv_grid[0].length;
					if (do_renew_csv_columns == true)
						new_task_type_this.csv_column_types.length = first_row_columns;
					if (first_row_columns > 0) {
						// label columns
						var tr = document.createElement("tr");
						for (var i = 0; i != first_row_columns; ++i) {
							var td = document.createElement("td");
							td.appendChild(document.createTextNode("Column " + (i + 1) + " (" + column_numeric_to_alpha(i) + ')'));
							tr.appendChild(td);
						}
						table.appendChild(tr);
						//
						tr = document.createElement("tr");
						for (var i = 0; i != first_row_columns; ++i) {
							var td = document.createElement("td");
							if (do_renew_csv_columns == true)
								td.appendChild((new_task_type_this.csv_column_types[i] = new select_csv_column_type(new_task_type_this, i)).gui);
							else
								td.appendChild(new_task_type_this.csv_column_types[i].gui);
							tr.appendChild(td);
						}
						table.appendChild(tr);

						for (var i = 0; i != rows; ++i) {
							var row = csv_grid[i];
							var tr = document.createElement("tr");
							for (var j = 0; j != row.length; ++j) {
								var td = document.createElement("td");
								td.className = "unspecified_csv";
								td.appendChild(document.createTextNode(row[j]));
								tr.appendChild(td);
							}
							table.appendChild(tr);
						}
						table.className = "auto_table";
						new_task_type_this.csv_table_holder.replaceChild(table, new_task_type_this.csv_table);
						new_task_type_this.csv_table = table;
						if (do_renew_csv_columns == false)
							for (var i = 0; i != first_row_columns; ++i)
								new_task_type_this.csv_column_types[i].gui.onchange();
					}
				}
			}
		}
		worker.postMessage({"message" : "preview_csv", "file" : tmp_file_choice.files[0], "rows" : tmp_csv_preview_rows.value });
	}

	tmp_file_choice.onchange = function ()
	{
		new_task_type_this.attributes = {};
		new_task_type_this.csv_column_types = [];
		populate_csv_table(true);
	}


	tmp_tr = document.createElement("tr");
	tmp_td = document.createElement("td");
	tmp_td.appendChild(document.createTextNode("Data starts from row no:"));
	tmp_tr.appendChild(tmp_td);
	tmp_td = document.createElement("td");
	var csv_data_from_row = document.createElement("input");
	csv_data_from_row.size = 5;
	csv_data_from_row.value = 2;
	tmp_td.appendChild(csv_data_from_row);
	tmp_tr.appendChild(tmp_td);
	tmp_tbl.appendChild(tmp_tr);

	tmp_tr = document.createElement("tr");

	tmp_td = document.createElement("td");
	var label = document.createElement("label");
	label.appendChild(document.createTextNode("Exclude rows foo:"));
	label.className = "extra_option_text"
	label.htmlFor = "csv_data_freeform_cli_delete_rows_value";

	var checkbox = document.createElement("input");
	checkbox.type = "checkbox";
	checkbox.checked = false;
	checkbox.id = "csv_data_freeform_cli_delete_rows_value";
	checkbox.onchange = function()
	{
		if (this.checked == true)
			csv_data_freeform_cli_delete_rows_value.disabled = false;
		else
			csv_data_freeform_cli_delete_rows_value.freeform_cli_value.disabled = true;
	}

	tmp_td.appendChild(checkbox);
	tmp_td.appendChild(label);
	tmp_tr.appendChild(tmp_td);

	tmp_td = document.createElement("td");
	var csv_data_freeform_cli_delete_rows_value = document.createElement("input");
	csv_data_freeform_cli_delete_rows_value.disabled = true;
	csv_data_freeform_cli_delete_rows_value.className = "freeform_cli";
	csv_data_freeform_cli_delete_rows_value.size = 15;
	tmp_td.appendChild(csv_data_freeform_cli_delete_rows_value);
	tmp_tr.appendChild(tmp_td);

	tmp_tbl.appendChild(tmp_tr);

	tmp_tr = document.createElement("tr");

	tmp_td = document.createElement("td");
	tmp_td.colSpan = 2;
	var label = document.createElement("label");
	label.className = "extra_option_text"
	var csv_data_sort = document.createElement("input");
	csv_data_sort.type = "checkbox";
	csv_data_sort.checked = false;
	label.appendChild(csv_data_sort);
	label.appendChild(document.createTextNode("Perform sorting of dataset (at the server)."));
	tmp_td.appendChild(label);
	tmp_tr.appendChild(tmp_td);

	tmp_tbl.appendChild(tmp_tr);


	tmp_tr = document.createElement("tr");
	tmp_td = document.createElement("td");
	tmp_td.colSpan = 2;
	var label = document.createElement("label");
	label.className = "extra_option_text"
	var csv_preprocess = document.createElement("input");
	csv_preprocess.type = "checkbox";
	csv_preprocess.checked = true;
	label.appendChild(csv_preprocess);
	label.appendChild(document.createTextNode("Strip'n'zip dataset before sending to server."));
	tmp_td.appendChild(label);
	tmp_tr.appendChild(tmp_td);
	tmp_tbl.appendChild(tmp_tr);


	td.appendChild(tmp_tbl);

	td.appendChild(document.createElement("hr"));

	this.csv_table_holder = document.createElement("div");
	this.csv_table_holder.id = "overflowish";
	this.csv_table_holder.style.maxWidth = (0.95 * document.documentElement.clientWidth) + "px";
	this.csv_table = document.createElement("table");
	this.csv_table_holder.appendChild(this.csv_table);
	td.appendChild(this.csv_table_holder);

	td.appendChild(document.createElement("hr"));

	var help_vcgw_coefficients_metadata_content = new help_content_type("Step 3: Configure VCGW exploration characteristics", "help_vcgw_coefficients_metadata_content");
	td.appendChild(help_vcgw_coefficients_metadata_content.gui);

	var tmp_tbl = document.createElement("table");
	tmp.className = "auto_table";
	tmp_tr = document.createElement("tr");
	tmp_td = document.createElement("td");

	tmp_td.appendChild(document.createTextNode("Max-coefficients-@once complexity size:"));
	tmp_tr.appendChild(tmp_td);

	tmp_td = document.createElement("td");
	tmp_td.appendChild(coeffs_atonce);
	tmp_tr.appendChild(tmp_td);
	tmp_tbl.appendChild(tmp_tr);

	tmp_tr = document.createElement("tr");
	tmp_td = document.createElement("td");
	tmp_td.appendChild(document.createTextNode("Number of additional complexity settings:"));
	tmp_tr.appendChild(tmp_td);

	tmp_td = document.createElement("td");
	var subsequent_complexities_size = document.createElement("input");
	subsequent_complexities_size.type = "number";
	subsequent_complexities_size.size = 5;
	subsequent_complexities_size.value = 0;
	subsequent_complexities_size.onchange = function() 
	{
		if (isNaN(parseInt(this.value)) == false) {
			var newdivx = document.createElement("div");
			for (var i = 0; i < this.value; ++i)
				(subsequent_complexities[i] = new subsequent_complexity_type(new_task_type_this)).populate(newdivx);
			initial_complexity_table_holder.replaceChild(newdivx, subsequent_complexity_tables_holder);
			subsequent_complexity_tables_holder = newdivx;
		}
	}
	tmp_td.appendChild(subsequent_complexities_size);
	tmp_tr.appendChild(tmp_td);
	tmp_tbl.appendChild(tmp_tr);

	td.appendChild(tmp_tbl);

	td.appendChild(document.createElement("hr"));

	var all_complexity_tables_holder = td;
	var initial_complexity_table_holder = document.createElement("div");
	var subsequent_complexity_tables_holder = document.createElement("div");
	initial_complexity_table_holder.appendChild(initial_complexity_table);
	initial_complexity_table_holder.appendChild(subsequent_complexity_tables_holder);

	td.appendChild(initial_complexity_table_holder);

	td.appendChild(document.createElement("hr"));
	var help_vcgw_misc_content = new help_content_type("Step 4: Finish configuring VCGW", "help_vcgw_misc_content");
	td.appendChild(help_vcgw_misc_content.gui);

	tmp_tbl = document.createElement("table");

	tmp_tr = document.createElement("tr");
	tmp_td = document.createElement("td");
	tmp_td.appendChild(document.createTextNode("Max. evaluations in any complexity:"));
	tmp_tr.appendChild(tmp_td);
	tmp_td = document.createElement("td");
	var complexity_size = document.createElement("input");
	complexity_size.type = "number";
	complexity_size.size = 10;
	complexity_size.value = 3000000;
	tmp_td.appendChild(complexity_size);
	tmp_tr.appendChild(tmp_td);
	tmp_tbl.appendChild(tmp_tr);

	tmp_tr = document.createElement("tr");
	tmp_td = document.createElement("td");
	tmp_td.appendChild(document.createTextNode("Number of draws:"));
	tmp_tr.appendChild(tmp_td);
	tmp_td = document.createElement("td");
	var repeats = document.createElement("input");
	repeats.type = "number";
	repeats.size = 10;
	repeats.value = 1000;
	repeats.disabled = true;
	tmp_td.appendChild(repeats);
	tmp_tr.appendChild(tmp_td);
	tmp_tbl.appendChild(tmp_tr);

	tmp_tr = document.createElement("tr");
	tmp_td = document.createElement("td");
	tmp_td.appendChild(document.createTextNode("Number of drawn sets:"));
	tmp_tr.appendChild(tmp_td);
	tmp_td = document.createElement("td");
	var draws_sets_size = document.createElement("input");
	draws_sets_size.type = "number";
	draws_sets_size.size = 10;
	draws_sets_size.value = 1;
	draws_sets_size.disabled = true;
	tmp_td.appendChild(draws_sets_size);
	tmp_tr.appendChild(tmp_td);
	tmp_tbl.appendChild(tmp_tr);

	tmp_tr = document.createElement("tr");
	tmp_td = document.createElement("td");
	tmp_td.appendChild(document.createTextNode("Zoom-in slowdown:"));
	tmp_tr.appendChild(tmp_td);
	tmp_td = document.createElement("td");
	var shrink_slowdown = document.createElement("input");
	shrink_slowdown.type = "number";
	shrink_slowdown.size = 10;
	shrink_slowdown.value = 0.3;
	tmp_td.appendChild(shrink_slowdown);
	tmp_tr.appendChild(tmp_td);
	tmp_tbl.appendChild(tmp_tr);

	tmp_tr = document.createElement("tr");
	tmp_td = document.createElement("td");
	tmp_td.appendChild(document.createTextNode("Min. improvement ratio:"));
	tmp_tr.appendChild(tmp_td);
	tmp_td = document.createElement("td");
	var minimpr = document.createElement("input");
	minimpr.type = "number";
	minimpr.size = 10;
	minimpr.value = 1.0000001;
	tmp_td.appendChild(minimpr);
	tmp_tr.appendChild(tmp_td);
	tmp_tbl.appendChild(tmp_tr);

	tmp_tr = document.createElement("tr");
	tmp_td = document.createElement("td");
	tmp_td.appendChild(document.createTextNode("Floating-point res:"));
	tmp_tr.appendChild(tmp_td);
	tmp_td = document.createElement("td");
	var floating_point_resolution = document.createElement("select");
	floating_point_resolution.size = 1;

	var tmp_option;
	/*
	tmp_option = document.createElement("option");
	tmp_option.value = 0;
	tmp_option.appendChild(document.createTextNode("not set"));
	floating_point_resolution.appendChild(tmp_option);
	*/

	tmp_option = document.createElement("option");
	tmp_option.value = 1;
	tmp_option.selected = true;
	tmp_option.appendChild(document.createTextNode("single (32-bit)"));
	floating_point_resolution.appendChild(tmp_option);

	tmp_option = document.createElement("option");
	tmp_option.value = 2;
	tmp_option.appendChild(document.createTextNode("double (64-bit)"));
	floating_point_resolution.appendChild(tmp_option);

	tmp_td.appendChild(floating_point_resolution);
	tmp_tr.appendChild(tmp_td);

	tmp_tbl.appendChild(tmp_tr);

	tmp_tr = document.createElement("tr");
	tmp_td = document.createElement("td");
	tmp_td.appendChild(document.createTextNode("Extended floating-point res:"));
	tmp_tr.appendChild(tmp_td);

	tmp_td = document.createElement("td");
	var extended_floating_point_resolution = document.createElement("select");
	extended_floating_point_resolution.size = 1;

	/*
	tmp_option = document.createElement("option");
	tmp_option.value = 0;
	tmp_option.appendChild(document.createTextNode("not set"));
	extended_floating_point_resolution.appendChild(tmp_option);
	*/

	tmp_option = document.createElement("option");
	tmp_option.value = 1;
	tmp_option.appendChild(document.createTextNode("single (32-bit)"));
	extended_floating_point_resolution.appendChild(tmp_option);

	tmp_option = document.createElement("option");
	tmp_option.value = 2;
	tmp_option.selected = true;
	tmp_option.appendChild(document.createTextNode("double (64-bit)"));
	extended_floating_point_resolution.appendChild(tmp_option);

	tmp_td.appendChild(extended_floating_point_resolution);
	tmp_tr.appendChild(tmp_td);

	tmp_tbl.appendChild(tmp_tr);

	tmp_tr = document.createElement("tr");
	tmp_td = document.createElement("td");
	tmp_td.appendChild(document.createTextNode("Integer/memory-size res:"));
	tmp_tr.appendChild(tmp_td);

	tmp_td = document.createElement("td");
	var integer_resolution = document.createElement("select");
	integer_resolution.size = 1;

	/*
	tmp_option = document.createElement("option");
	tmp_option.value = 0;
	tmp_option.appendChild(document.createTextNode("not set"));
	integer_resolution.appendChild(tmp_option);
	*/

	tmp_option = document.createElement("option");
	tmp_option.value = 1;
	tmp_option.selected = true;
	tmp_option.appendChild(document.createTextNode("32-bit"));
	integer_resolution.appendChild(tmp_option);

	tmp_option = document.createElement("option");
	tmp_option.value = 2;
	tmp_option.appendChild(document.createTextNode("64-bit"));
	integer_resolution.appendChild(tmp_option);

	tmp_td.appendChild(integer_resolution);
	tmp_tr.appendChild(tmp_td);

	tmp_tbl.appendChild(tmp_tr);

	tmp_tr = document.createElement("tr");
	tmp_td = document.createElement("td");
	tmp_td.appendChild(document.createTextNode("Approximate exponents:"));
	tmp_tr.appendChild(tmp_td);

	tmp_td = document.createElement("td");
	var approximate_exponents = document.createElement("select");
	approximate_exponents.size = 1;

	tmp_option = document.createElement("option");
	tmp_option.value = 1;
	tmp_option.selected = true;
	tmp_option.appendChild(document.createTextNode("ON"));
	approximate_exponents.appendChild(tmp_option);

	tmp_option = document.createElement("option");
	tmp_option.value = 0;
	tmp_option.appendChild(document.createTextNode("Off"));
	approximate_exponents.appendChild(tmp_option);

	tmp_td.appendChild(approximate_exponents);
	tmp_tr.appendChild(tmp_td);

	tmp_tbl.appendChild(tmp_tr);

	td.appendChild(tmp_tbl);

	function compose_cli_cm_gridres_args(x)
	{
		var compressed_grid_resolutions_length = x.length;
		var ref_value = x[x.length - 1].value;
		for (var j = x.length - 2; j  > -1; --j) {
			if (ref_value == x[j].value)
				--compressed_grid_resolutions_length;
			else 
				break;
		}
		var this_row = "";
		for (var j = 0; j != compressed_grid_resolutions_length; ++j)
			this_row += ':' + x[j].value;
		return this_row;
	}

	td.appendChild(document.createElement("hr"));

	var help_short_description_content = new help_content_type("Step 5: Provide a short one-phrase project description", "help_short_description_content");
	td.appendChild(help_short_description_content.gui);
	
	var short_description_input = document.createElement("input");
	short_description_input.className = "short_description";
	short_description_input.maxlength = 100;
	td.appendChild(short_description_input);

	td.appendChild(document.createElement("hr"));

	var to_server = document.createElement("pre"); 
	// to_server.innerHTML = "";
	to_server.className = "debug_log_to_server";

	var from_server = document.createElement("pre");
	from_server.className = "debug_log_from_server";
	td.appendChild(from_server);

	var waiting_animation = new waiting_animation_type(td);

	var send_to_server_button = document.createElement("button")
	function bail_on_wrong_user_values(text)
	{
		alert(text);
		send_to_server_button.disabled = false;
	}

	send_to_server_button.onclick = function() 
	{

		var form = new FormData();

		var fromrow = parseInt(csv_data_from_row.value);
		var model_value = parseInt(new_task_type_this.model.value);
		var floating_point_resolution_value = parseInt(floating_point_resolution.value);
		var extended_floating_point_resolution_value = parseInt(extended_floating_point_resolution.value);
		var integer_resolution_value = parseInt(integer_resolution.value);
		var approximate_exponents_value = parseInt(approximate_exponents.value);
		var complexity_size_value = parseInt(complexity_size.value);
		var minimpr_value = parseFloat(minimpr.value);
		var draws_sets_size_value = parseInt(draws_sets_size.value);
		var shrink_slowdown_value = parseFloat(shrink_slowdown.value);
		var repeats_value = parseInt(repeats.value);

		var cli_string = short_description_input.value + '\n';

		if (!short_description_input.value.length || short_description_input.value.length > 100)
			return bail_on_wrong_user_values("Must supply a short (under 100 chars) one-phrase -line project description");

		cli_string += "--model " + model_value + ":offer\n";
		cli_string += "--fromrow " + fromrow  + '\n';

		form.append("--model_id", model_value);

		var attributes_size = 0;
		var attributes_1based_indicies = [];
		var respondent_i = 0;
		var choice_set_i = 0;
		var alternative_i = 0;
		var choice_i = 0; 
		for (var i = 0; i != new_task_type_this.csv_column_types.length; ++i) {
			switch (new_task_type_this.csv_column_types[i].gui.value) {
				case '1':
					respondent_i = i + 1;
					break;
				case '2':
					choice_set_i = i + 1;
					break;
				case '3':
					alternative_i = i + 1;
					break;
				case '4':
					attributes_1based_indicies[attributes_size] = i + 1;
					attributes_1based_indicies.length = ++attributes_size;
					break;
				case '5':
					choice_i = i + 1;
					break;
			}
		}

		if (repeats_value < 1 || shrink_slowdown_value >= 1 || shrink_slowdown_value < 0 || draws_sets_size_value < 1 || minimpr_value < 1 || !floating_point_resolution_value || !extended_floating_point_resolution_value || !integer_resolution_value || !attributes_1based_indicies.length || !model_value || !respondent_i || !choice_set_i || !alternative_i || !choice_i || isNaN(fromrow) == true || fromrow < 1  || !cli_coefficient_range_metadata.length) 
			return bail_on_wrong_user_values("Did not fill all of the values properly... naughty naughty...");

		switch (integer_resolution_value) {
			case 1:
				cli_string += "--int_resolution 32\n";
				form.append("--int_resolution", 32);
				break;
			case 2:
				cli_string += "--int_resolution 64\n";
				form.append("--int_resolution", 64);
				break;
		}
		if (approximate_exponents_value) {
			cli_string += "--approximate_exponents true\n";
			form.append("--approximate_exponents", 'true');
		} else {
			cli_string += "--approximate_exponents false\n";
			form.append("--approximate_exponents", 'false');
		}
		switch (floating_point_resolution_value) {
			case 1:
				cli_string += "--float_resolution single\n";
				form.append("--float_resolution", "single");
				break;
			case 2:
				cli_string += "--float_resolution double\n";
				form.append("--float_resolution", "double");
				break;
		}
		switch (extended_floating_point_resolution_value) {
			case 1:
				cli_string += "--extended_float_resolution single\n";
				form.append("--extended_float_resolution", "single");
				break;
			case 2:
				cli_string += "--extended_float_resolution double\n";
				form.append("--extended_float_resolution", "double");
				break;
		}

		cli_string += "--respondent " + respondent_i + '\n';

		cli_string += "--choice_set " + choice_set_i + '\n';

		cli_string += "--alternative " + alternative_i + '\n';


		if (repeats.disabled == false) {
			cli_string += "--repeats " + repeats_value + '\n';
			form.append("--repeats", repeats_value);
		}

		if (draws_sets_size.disabled == false) {
			cli_string += "--draws_sets_size " + draws_sets_size_value + '\n';
			form.append("--draws_sets_size", draws_sets_size_value);
		}

		cli_string += "--best " + choice_i + '\n';

		cli_string += "--complexity_size " + complexity_size_value + '\n';
		form.append("--complexity_size", complexity_size_value);

		cli_string += "--minimpr " + minimpr_value + '\n';
		form.append("--minimpr", minimpr_value);

		cli_string += "--shrink_slowdown " + shrink_slowdown_value + '\n';
		form.append("--shrink_slowdown", shrink_slowdown_value);

		var delby = [];
		var del_strings = [];
		if (csv_data_freeform_cli_delete_rows_value.disabled == false && csv_data_freeform_cli_delete_rows_value.value.length) {
			var tmps = csv_data_freeform_cli_delete_rows_value.value.split(/\s+/);
			if (!tmps.length)
				return bail_on_wrong_user_values("\"Exclude rows foo\" is incorrectly formed.");
			for (var i = 0; i != tmps.length; ++i) {
				var tmp_ = tmps[i].split(':');
				if (tmp_.length != 3 || isNaN(tmp_[2]) || (tmp_[1] != "lt" && tmp_[1] != "le" && tmp_[1] != "eq" && tmp_[1] != "ne" && tmp_[1] != "ge" && tmp_[1] != "gt"))
					return bail_on_wrong_user_values("One of the specifications in \"Exclude rows foo\" is incorrectly formed: " + tmps[i]);
				cli_string += "--del " + tmps[i] + '\n';
				del_strings.push(tmps[i]);
				delby.push(
					{
					"column" : tmp_[0], "op" : tmp_[1], "val" : tmp_[2]
					}
				);
			}
		}

		cli_string += "--dissect off\n--reduce_exp_complexity off\n";
		form.append("--dissect", "off");
		form.append("--reduce_exp_complexity", "off");

		var sort_str = "";
		if (csv_data_sort.checked == true) {
			sort_str = respondent_i + ',' + choice_set_i;
			sort_str += ',' + alternative_i;
			cli_string += "--sort " + sort_str + '\n';
		}

		var tmp_attribute_i = 0;
		var x_str = attributes_1based_indicies[0];
		for (var i = 1, expected = attributes_1based_indicies[0] + 1; i < attributes_1based_indicies.length; ++i, ++expected) {
			var diff = i - tmp_attribute_i;
			if (expected != attributes_1based_indicies[i]) {
				if (diff > 2)
					x_str += ':' + attributes_1based_indicies[i - 1];
				else if (diff > 1)
					x_str += ',' + attributes_1based_indicies[i - 1];
				x_str += ',' + attributes_1based_indicies[i];
				expected = attributes_1based_indicies[i];
				tmp_attribute_i = i;
			} else if (i == attributes_1based_indicies.length - 1) {
				if (diff > 1)
					x_str += ':' + attributes_1based_indicies[i];
				else 
					x_str += ',' + attributes_1based_indicies[i];
			}
		}

		cli_string += "--x " + x_str + '\n';


		// main coefficients metadata stuff
		cli_string += "--coeffs_atonce_size " + coeffs_atonce.value + '\n';
		form.append("--coeffs_atonce_size", coeffs_atonce.value);

		var last_row = "";
		for (var i = 0; i != cli_coefficient_range_metadata.length; ++i) {
			var cli = cli_coefficient_range_metadata[i];
			if (cli.validate() == false)
				return;
			var this_row = cli.from.value + ':' + cli.to.value + ':' + cli.minstep.value + compose_cli_cm_gridres_args(cli.grid_resolutions);
			if (this_row != last_row) {
				var cm_str = i + 1 + ':' + this_row;
				cli_string += "--cm " + cm_str + '\n';
				form.append("--cm", cm_str);
			}
			last_row = this_row;
		}

		// subsequent coefficients metadata stuff
		for (var i = 0; i < subsequent_complexities_size.value; ++i) {
			var subsequent_complexity = subsequent_complexities[i];
			if (parseInt(subsequent_complexity.coeffs_atonce.value) < 1)
				return bail_on_wrong_user_values("Subsequent compelxity table(=" + (i + 1) + ") does not have valid number of x-coefficients-@-once complexity.");
			cli_string += "--coeffs_atonce_size " + subsequent_complexity.coeffs_atonce.value + '\n';
			form.append("--coeffs_atonce_size", subsequent_complexity.coeffs_atonce.value);
			last_row = "";
			for (var j = 0; j != subsequent_complexity.cli_coefficient_range_metadata_x.length; ++j) {
				var cli = subsequent_complexity.cli_coefficient_range_metadata_x[j];
				if (cli.validate() == false)
					return;
				var this_row = cli.threshold.value + compose_cli_cm_gridres_args(cli.grid_resolutions);
				if (this_row != last_row) {
					var cm_str = j + 1 + ':' + this_row;
					cli_string += "--cm " + cm_str + '\n';
					form.append("--cm", cm_str);
				}
				last_row = this_row;
			}
		}

		if (parseInt(new_task_type_this.model.value) == 5) {
			cli_string += "--betas_sets_size " +  new_task_type_this.multi_logit_betas_sets_size_input.value + '\n';
			form.append("--betas_sets_size", new_task_type_this.multi_logit_betas_sets_size_input.value);
		}

		if (csv_preprocess.checked == true)
			cli_string += "--csv_strip_n_zip true\n";
		else
			cli_string += "--csv_strip_n_zip false\n";

		to_server.innerHTML = "some debug/CLI info:\n" + cli_string;

		form.append("--short_description", cli_string);

		function stop_waiting()
		{
			send_to_server_button.disabled = false;
			waiting_animation.stop();
		}

		send_to_server_button.disabled = true;

		// var form = new FormData(document.getElementById("aoeu"));
		var http_request = new XMLHttpRequest();
		http_request.withCredentials = true;
		var spurious_try_again_flag = true;
		http_request.onreadystatechange = function()
		{
			if (this.readyState == 4) {
				if (this.status == 200) {
					//alert(this.responseText);
					var obj = JSON.parse(this.responseText);
					if (obj.echo) {
						from_server.innerHTML = "Server says OK: " + obj.echo + "<em>New Task ID is</em> <b>ID=" + obj.task.split(/[_\-x]/g)[0] + "</b>";
					} else if (obj.error) {
						from_server.innerHTML = "Server says BAD: " + obj.error;
					}
					stop_waiting();
				} else if (this.status != 0 || spurious_try_again_flag == false) {
					stop_waiting();
					from_server.innerHTML = "Epic fail... [specifics are not yet diagnosed properly, the browser-communicated status code is " + this.status + ']';
				} else {
					spurious_try_again_flag = false;
					this.open("POST", server_at + "new_task");
					this.send(form);
				}
			} else if (this.readyState == 0) {
				stop_waiting();
			}
		}

		if (csv_preprocess.checked == false) {

			from_server.innerHTML = "SENDING TO SERVER... this may take some time, like minutes -- even if the dataset is small the server is still gonna do some chewing, and in debug mode at that -- indubitably. The finally-submitted dataset is " + (tmp_file_choice.files[0].size / (1024 * 1024)).toFixed(3) + "MB";


			waiting_animation.start();

			form.append("--fromrow", fromrow);
			form.append("--respondent", respondent_i);
			form.append("--choice_set", choice_set_i);
			form.append("--alternative", alternative_i);
			form.append("--best", choice_i);
			form.append("--x", x_str);
			for (var del_strings_i = 0; del_strings_i != del_strings.length; ++del_strings_i)
				form.append("--del", del_strings[del_strings_i]);
			if (csv_data_sort.checked == true)
				form.append("--sort", sort_str);
			form.append("--filedata", tmp_file_choice.files[0]);
			http_request.open("POST", server_at + "new_task");
			http_request.send(form);
		} else {
			form.append("--fromrow", 1);
			form.append("--respondent", 1);
			form.append("--choice_set", 2);
			form.append("--alternative", 3);
			form.append("--best", 4);
			for (var attributes_i = 0; attributes_i != attributes_1based_indicies.length; ++attributes_i)
				form.append("--x", attributes_i + 5);
			if (csv_data_sort.checked == true)
				form.append("--sort", "1,2,3");

			worker.onmessage = function(e) {
				if (e.data.message == "progress") {
					from_server.innerHTML = "STRIPPING CSV " + parseInt(e.data.percent) + "% done... please wait."
				} else if (e.data.message == "strip_csv") {
					//csv_grid = e.data.csv;
					zip.createWriter(new zip.BlobWriter(), function(writer) {
						writer.add("dataset.csv", new zip.TextReader(e.data.csv), function() {
							from_server.innerHTML = "ZIPPING CSV 100%... preparing to send to server...";
							writer.close(function(blob) {
								waiting_animation.start();

								from_server.innerHTML = "SENDING TO SERVER... this may take some time, like minutes -- even if the dataset is small the server is still gonna do some chewing, and in debug mode at that -- indubitably. The finally-submitted dataset is " + (blob.size / (1024 * 1024)).toFixed(3) + "Mb in size, whilst the originally-selected dataset file is " + (tmp_file_choice.files[0].size / (1024 * 1024)).toFixed(3) + "MB";
								form.append("--filedata.zip", blob);
								http_request.open("POST", server_at + "new_task");
								http_request.send(form);
								});
							}, function(currentIndex, totalIndex) {
								from_server.innerHTML = "ADDING CSV TO ZIP ARCHIVE... " + parseInt((100 * currentIndex) / totalIndex) + '%';
							});
						}, function(error) {
							from_server.innerHTML = "BOO -- zipping failed: " + error;
							send_to_server_button.disabled = true;
						}
					);
				}
			}
			var msg = {};
			msg.message = "strip_csv";
			msg.file = tmp_file_choice.files[0];
			msg.respondent_i = respondent_i;
			msg.choice_set_i = choice_set_i;
			msg.alternative_i = alternative_i;
			msg.choice_i = choice_i;
			msg.attributes = attributes_1based_indicies;
			msg.delby = delby;
			msg.fromrow = fromrow;
			worker.postMessage(msg);
		}
	}

	send_to_server_button.className = "full_width";
	send_to_server_button.appendChild(document.createTextNode("Send to server"));
	td.appendChild(send_to_server_button);

	tmp = document.createElement("button");
	tmp.className = "full_width";
	tmp.appendChild(document.createTextNode("Main Menu"));
	tmp.onclick = function() 
	{
		main_menu.show();
	}
	td.appendChild(tmp);

	td.appendChild(to_server);

	tr.appendChild(td);
	gui.appendChild(tr);

	this.show = function()
	{
		if (gui != last_div) {
			document.body.replaceChild(gui, last_div);
			last_div = gui;
		}
	}

	this.fill_down_row = function(x)
	{
		var source = cli_coefficient_range_metadata[x];
		for (var i = x + 1; i != cli_coefficient_range_metadata.length; ++i) {
			cli_coefficient_range_metadata[i].from.value = source.from.value;
			cli_coefficient_range_metadata[i].to.value = source.to.value;
			cli_coefficient_range_metadata[i].minstep.value = source.minstep.value;
			for (var j = 0; j != source.grid_resolutions.length; ++j)
				cli_coefficient_range_metadata[i].grid_resolutions[j].value = source.grid_resolutions[j].value;
		}
	}

	this.fill_down_column_from = function(x)
	{
		var value = cli_coefficient_range_metadata[x].from.value;
		for (var i = x + 1; i != cli_coefficient_range_metadata.length; ++i)
			cli_coefficient_range_metadata[i].from.value = value;
	}

	this.fill_down_column_to = function(x)
	{
		var value = cli_coefficient_range_metadata[x].to.value;
		for (var i = x + 1; i != cli_coefficient_range_metadata.length; ++i)
			cli_coefficient_range_metadata[i].to.value = value;
	}

	this.fill_down_column_minstep = function(x)
	{
		var value = cli_coefficient_range_metadata[x].minstep.value;
		for (var i = x + 1; i != cli_coefficient_range_metadata.length; ++i)
			cli_coefficient_range_metadata[i].minstep.value = value;
	}

	this.fill_down_column_grid_resolutions = function(x, y)
	{
		var value = cli_coefficient_range_metadata[x].grid_resolutions[y].value;
		for (var i = x + 1; i != cli_coefficient_range_metadata.length; ++i)
			cli_coefficient_range_metadata[i].grid_resolutions[y].value = value;
	}

	this.fill_right_row_grid_resolutions = function(x, y)
	{
		var value = cli_coefficient_range_metadata[x].grid_resolutions[y].value;
		for (var i = y + 1; i != cli_coefficient_range_metadata[x].grid_resolutions.length; ++i)
			cli_coefficient_range_metadata[x].grid_resolutions[i].value = value;
	}

	this.fill_to_corner = function(x, y)
	{
		var value = cli_coefficient_range_metadata[x].grid_resolutions[y].value;
		for (var j = x; j != cli_coefficient_range_metadata.length; ++j) {
			for (var i = y; i != cli_coefficient_range_metadata[j].grid_resolutions.length; ++i) {
				cli_coefficient_range_metadata[j].grid_resolutions[i].value = value;
			}
		}
	}
}

function batch_fill_context_menu_type()
{
	var batch_fill_context_menu_type_this = this;
	var hidden = true;
	var highlighted_cell_gui;
	var x, y;
	this.show = function()
	{
		if (hidden == false)
			this.hide();
		this.cell_gui.className = "coeff_metadata_selected";
		highlighted_cell_gui = this.cell_gui;
		hidden = false;

		var visible_dims = document.getElementById("visible_dims");
		
		gui.style.left = "0px";
		gui.style.top = "0px";
		document.body.appendChild(gui);

		var right = gui.clientWidth + x;
		if (right > visible_dims.scrollWidth) {
			x = x - right + visible_dims.scrollWidth;
			if (x < 0)
				x = 0;
			gui.style.left = x + window.pageXOffset + "px";
		} else
			gui.style.left = x + window.pageXOffset + "px";
		var bottom = gui.clientHeight + y;
		if (bottom > visible_dims.scrollHeight) {
			y = y - bottom + visible_dims.scrollHeight;
			if (y < 0)
				y = 0;
			gui.style.top = y + window.pageYOffset + "px";
		} else
			gui.style.top = y  + window.pageYOffset+ "px";
	}
	this.hide = function()
	{
		if (hidden == false) {
			highlighted_cell_gui.className = "coeff_metadata";
			document.body.removeChild(gui);
			hidden = true;
		}
	}

	var gui = document.createElement("div");
	gui.className = "contextmenu";

	this.fill_right_row_button = document.createElement("button");
	this.fill_right_row_button.className = "full_width";
	this.fill_right_row_button.appendChild(document.createTextNode("Fill right"));
	gui.appendChild(this.fill_right_row_button);

	this.fill_down_row_button = document.createElement("button");
	this.fill_down_row_button.className = "full_width";
	this.fill_down_row_button.appendChild(document.createTextNode("Fill row down"));
	gui.appendChild(this.fill_down_row_button);

	this.fill_down_column_button = document.createElement("button");
	this.fill_down_column_button.className = "full_width";
	this.fill_down_column_button.appendChild(document.createTextNode("Fill column down"));
	gui.appendChild(this.fill_down_column_button);

	this.fill_to_corner_button = document.createElement("button");
	this.fill_to_corner_button.className = "full_width";
	this.fill_to_corner_button.appendChild(document.createTextNode("Fill down and right"));
	gui.appendChild(this.fill_to_corner_button);

	var cancel_btn = document.createElement("button");
	cancel_btn.className = "full_width";
	cancel_btn.appendChild(document.createTextNode("Cancel"));
	cancel_btn.onclick = function() 
	{
		batch_fill_context_menu_type_this.hide();
	}
	gui.appendChild(cancel_btn);

	this.set_coordinates = function(new_x, new_y)
	{
		x = new_x;
		y = new_y;
	}
}

var normals_i = 0;
var normals = [];
function draw_from_normal() 
{
	var x1;
	var rad;
	do {
		var r1 = Math.random();
		x1 = r1 + r1  - 1;
		var r2 = Math.random();
		var x2 = r2 + r2 - 1;
		rad = x1 * x1 + x2 * x2
	} while (rad > .999 || rad < 0.001);
	return x1 * Math.sqrt(-2 * Math.log(rad) / rad);
}

// todo -- later, if need be, introduce more tuning params
function shaking_oscillator_type(initial_shaking_frequency, shaking_amplitude_reduction, shaking_frequency_increase)
{
	var amplitude_end = 0.003
	var amplitude = 0;
	var rotation_speed;
	var rotation;

	this.reset = function()
	{
		amplitude = 1;
		rotation_speed = initial_shaking_frequency;
		rotation = 0;
	}

	this.is_shaking = function()
	{
		return amplitude > amplitude_end ? true : false;
	}

	this.ping = function(duration)
	{
		var rv = Math.max(0, amplitude) * Math.cos(rotation);
		rotation += rotation_speed;
		rotation_speed += duration * shaking_frequency_increase;
		amplitude -= duration * shaking_amplitude_reduction;
		return rv;
	}
}

function value_interpolator_type(interpolation_speed, initial_shaking_frequency, shaking_amplitude_reduction, shaking_frequency_increase)
{
	var current_value;
	var target_value;
	var abs_target_value;
	var shaker = new shaking_oscillator_type(initial_shaking_frequency, shaking_amplitude_reduction, shaking_frequency_increase);
	var ping_helper;
	var done;
	var initial_shaking;

	this.reset = function(current_value_, target_value_, initial_shaking_)
	{
		current_value = current_value_;
		target_value = target_value_;
		abs_target_value = Math.abs(target_value);
		initial_shaking = initial_shaking_;
		done = false;
		shaker.reset();
		ping_helper = ping_helper_on_travelling;
	}

	function ping_helper_on_shaking(duration_since_last)
	{
		current_value = target_value + initial_shaking * shaker.ping(duration_since_last);
		if (shaker.is_shaking() == false)
			done = true;
	}

	function ping_helper_on_travelling(duration_since_last)
	{
		var diff = target_value - current_value;
		var abs_diff = Math.abs(diff);
		if (abs_diff < abs_target_value * 0.03)
			ping_helper = ping_helper_on_shaking;
		else 
			current_value += Math.min(0.9, interpolation_speed * duration_since_last) * diff;
	}

	this.ping = function(duration_since_last)
	{
		ping_helper(duration_since_last);
	}

	this.is_done = function()
	{
		return done;
	}

	this.get_current_value = function()
	{
		return current_value;
	}

}

waiting_animation_type.rotation_speed = 0.001;
function waiting_animation_type(gui_holder)
{
	var gui = document.createElement("div");
	gui.className = "waiting_animation";
	gui_holder.appendChild(gui);
	var canvas = document.createElement("canvas");
	var diameter = 100;
	var outer_radius = diameter * 0.5;
	var inner_radius = 15;
	canvas.width = diameter + 20;
	canvas.height = diameter + 20;
	var canvas_center = canvas.width * 0.5;
	var animation_timer = null;
	var stopped = true;
	var ctx = canvas.getContext("2d"); 

	var value_interpolator = new value_interpolator_type(0.005, 0.1, 0.00065, 0.0012);

	var target_radius_orientation;
	var current_rotation;
	var current_rotation_end;
	var rotation_pause_countdown;
	var rotation_gradient_choice;
	var prev_tick_timestamp;

	function reset()
	{
		value_interpolator.reset(inner_radius, inner_radius, 5.7);
		target_radius_orientation = 0;
		current_rotation = 0;
		current_rotation_end = 0.1;
		rotation_pause_countdown = 0;
		rotation_gradient_choice = 1;
		prev_tick_timestamp = 0;
	}

	reset();

	var tick_duration;

	function tick(now)
	{
		if (stopped == true)
			return;

		tick_duration = now - prev_tick_timestamp;
		prev_tick_timestamp = now;

		if (value_interpolator.is_done() == false)
			value_interpolator.ping(tick_duration);
		else if ((rotation_pause_countdown -= tick_duration) < 0) {
			if (target_radius_orientation) {
				rotation_pause_countdown = 3000;
				value_interpolator.reset(outer_radius, inner_radius, -3);
			} else {
				rotation_pause_countdown = 5000;
				value_interpolator.reset(inner_radius, outer_radius, 5.7);
			}
			target_radius_orientation = !target_radius_orientation;
		} 

		current_rotation += waiting_animation_type.rotation_speed * tick_duration;
		if (current_rotation > two_pi)
			current_rotation %= two_pi;

		current_rotation_end += waiting_animation_type.rotation_speed * tick_duration;
		if (current_rotation_end > two_pi) {
			current_rotation_end %= two_pi;
			rotation_gradient_choice = !rotation_gradient_choice;
		}

		ctx.clearRect(0, 0, canvas.width, canvas.height);

		// circle
		var grd = ctx.createRadialGradient(canvas_center, canvas_center, 1, canvas_center, canvas_center, value_interpolator.get_current_value());
		var blue_value = parseInt(Math.min(255, 100 + 180 * Math.abs(value_interpolator.get_current_value() - inner_radius) / (outer_radius - inner_radius)));
		grd.addColorStop(0, "rgba(0,0," + blue_value + ", 1)");
		grd.addColorStop(1, "rgba(0,0," + blue_value + ", 0.2)");
		ctx.fillStyle = grd;
		ctx.beginPath();
		ctx.arc(canvas_center, canvas_center, value_interpolator.get_current_value(), 0, two_pi);
		ctx.fill();
		ctx.closePath();

		// rotating portion
		ctx.beginPath();
		ctx.fillStyle = "rgba(0, 0, 128, 0.3)";
		ctx.moveTo(canvas_center, canvas_center);
		var arc_end = current_rotation + current_rotation_end;
		if (rotation_gradient_choice) {
			arc_start = current_rotation;
			arc_end = current_rotation + current_rotation_end; 
		} else {
			arc_start = current_rotation + current_rotation_end;
			arc_end = current_rotation; 
		}
		ctx.arc(canvas_center, canvas_center, value_interpolator.get_current_value(), arc_start, arc_end);
		ctx.lineTo(canvas_center, canvas_center);
		ctx.fill();
		ctx.closePath();

		animation_timer = request_animation_frame(tick);
	}

	this.start = function()
	{
		gui.appendChild(canvas);
		stopped = false;
		tick(prev_tick_timestamp);
	}

	this.restart = function()
	{
		reset();
		this.start();
	}

	this.stop = function()
	{
		if (stopped == false) {
			stopped = true;
			cancel_animation_frame(animation_timer);
			gui.removeChild(canvas);
		}
	}
}

// todo perhaps have two types -- one for overlay comparison and another for animation (if any will prove to be of use that is).
//{ canvas_painter_type static variables
canvas_painter_type.normal_trunc = 2.5;
canvas_painter_type.max = 1 + canvas_painter_type.normal_trunc * .7;
canvas_painter_type.min = -canvas_painter_type.normal_trunc * .7;
canvas_painter_type.range = canvas_painter_type.max - canvas_painter_type.min;
canvas_painter_type.coefficient_circle_radius = Math.min(0.8 * window.innerHeight, 7 * 20) / 20;
canvas_painter_type.coefficient_circle_padding = canvas_painter_type.coefficient_circle_radius * 5;
canvas_painter_type.canvas_height = canvas_painter_type.coefficient_circle_radius * 30;
canvas_painter_type.zero_line_y = canvas_painter_type.canvas_height * canvas_painter_type.max / canvas_painter_type.range;
canvas_painter_type.height_over_range = canvas_painter_type.canvas_height / canvas_painter_type.range;
canvas_painter_type.comparative_chart_coeff_center_radius = canvas_painter_type.coefficient_circle_radius * 1.5;
canvas_painter_type.comparative_chart_coeff_center_diameter = canvas_painter_type.comparative_chart_coeff_center_radius * 2;
canvas_painter_type.comparative_chart_coeff_center_line_width = 0.5;
canvas_painter_type.comparative_chart_coeff_center_y_padding = canvas_painter_type.comparative_chart_coeff_center_radius + canvas_painter_type.comparative_chart_coeff_center_line_width;
canvas_painter_type.comparative_chart_y_padding = canvas_painter_type.comparative_chart_coeff_center_y_padding * 2;
//}

// todo -- may be break into model-specific painter types...
function canvas_painter_type(canvas, terrain_elevation_value_, coefficients, task_id, model_id, model_name, betas_size) 
{
	var canvas_painter_type_this = this;

	var painted_task_name = "ID=" + task_id + " (" + model_name + ')';

	var terrain_elevation_value = model_id < 6 ? -terrain_elevation_value_ : terrain_elevation_value_;
	var drawn_coefficients_size;
	switch (model_id) {
	case 1:
	case 5:
	drawn_coefficients_size = betas_size;
	break;
	default:
	drawn_coefficients_size = betas_size * 2;
	}

	canvas.width = (canvas_painter_type.coefficient_circle_radius * 2 + canvas_painter_type.coefficient_circle_padding) * drawn_coefficients_size - canvas_painter_type.coefficient_circle_padding + 20; // todo (make it more proper: add proper font-text-labels overflow to the right...  
	canvas.height = canvas_painter_type.canvas_height;
	//canvas.style.border = "1px solid black";

	var ctx = canvas.getContext("2d"); 

	function value_to_y_coord(value)
	{
		return canvas_painter_type.canvas_height - (value - canvas_painter_type.min) * canvas_painter_type.height_over_range;
	}
	
	this.get_task_name_metrics = function(context)
	{
		return context.measureText(painted_task_name);
	}

	this.get_terrain_elevation_value = function()
	{
		return terrain_elevation_value;
	}

	var normalised_value = coefficients[0].normalised_value;

	switch (model_id) {
	case 2:
	case 3:
	case 4:
	for (var i = betas_size; i != drawn_coefficients_size; ++i) {
		var tmp = Math.abs(coefficients[i].normalised_value);
		if (normalised_value < tmp)
			normalised_value = tmp;
	}
	case 1:
	case 5:
	for (var i = 1; i < drawn_coefficients_size; ++i)
		if (normalised_value < coefficients[i].normalised_value)
			normalised_value = coefficients[i].normalised_value;
	}

	this.get_max_normalised_value = function()
	{
		return normalised_value;
	}

	this.paint_comparison = function(context, label_y, label_font_size, terrain_elevation_value_left, terrain_elevation_value_middle, terrain_elevation_value_right, task_name_left, task_name_right, coefficients_left, min_terrain_elevation_value, terrain_elevation_value_scaler, coefficients_value_scaler, canvas_height)
	{
		context.lineWidth = 1.5;

		context.fillText(painted_task_name, task_name_left, canvas_height - label_y);
		context.beginPath();
		var terrain_elevation_value_y = canvas_height - (terrain_elevation_value - min_terrain_elevation_value) * terrain_elevation_value_scaler - canvas_painter_type.comparative_chart_coeff_center_y_padding;
		context.moveTo(terrain_elevation_value_left, terrain_elevation_value_y);
		context.lineTo(terrain_elevation_value_right, terrain_elevation_value_y);
		context.stroke();
		context.closePath();
		context.lineWidth = 0.47;
		context.beginPath();
		context.moveTo(terrain_elevation_value_middle, terrain_elevation_value_y);

		var text_midpoint_y = canvas_height - label_y - label_font_size * .3;
		context.lineTo(task_name_left, text_midpoint_y);

		context.moveTo(task_name_left + this.get_task_name_metrics(context).width, text_midpoint_y);
		context.lineTo(task_name_right, text_midpoint_y);

		context.stroke();
		context.closePath();

		var first_coefficient_centre = coefficients_left + canvas_painter_type.coefficient_circle_radius;

		context.beginPath();
		context.moveTo(task_name_right, text_midpoint_y);

		var coefficient_centre = first_coefficient_centre;
		for (var i = 0; i < drawn_coefficients_size; ++i, coefficient_centre += coefficient_centre_stepsize)
			context.lineTo(coefficient_centre, canvas_height - coefficients[i].normalised_value * coefficients_value_scaler - canvas_painter_type.comparative_chart_coeff_center_y_padding);

		context.stroke();
		context.closePath();

		var font_size = canvas_painter_type.comparative_chart_coeff_center_diameter * .8;
		var font_offset = canvas_painter_type.comparative_chart_coeff_center_diameter - font_size;
		// unicode codes for subscript betas are not, yet, supported in Source Sans Pro"
		context.font = font_size + "px Arimo";
		context.lineWidth = canvas_painter_type.comparative_chart_coeff_center_line_width;

		function number_to_subscript_string(x)
		{
			var rv = "";
			var str = x.toString();
			for (var str_i = 0; str_i != str.length; ++str_i)
				rv += String.fromCharCode(8320 + parseInt(str[str_i]));
			return rv;
		}

		// todo -- currently still escaping (in case the code is being edited with fonts which do not have displaying symobls)
		var beta_text = "\u03b2";
		var beta_char_half_width = context.measureText(beta_text).width * .5;

		switch (model_id) {
		case 2:
		case 3:
		case 4: 
		{
			var sigma_text = "\u03c3";
			var sigma_char_half_width = context.measureText(sigma_text).width * .5;
			sigma_text += "\u1D66";
			coefficient_centre = first_coefficient_centre + coefficient_centre_stepsize * betas_size;
			for (var i = 0; i != betas_size; ++i, coefficient_centre += coefficient_centre_stepsize) {
				var y_value = canvas_height - coefficients[betas_size + i].normalised_value * coefficients_value_scaler - canvas_painter_type.comparative_chart_coeff_center_y_padding + font_offset;
				context.fillText(sigma_text + number_to_subscript_string(i + 1), coefficient_centre - sigma_char_half_width, y_value);
			}
		}
		case 1: 
		case 5:
		{
			coefficient_centre = first_coefficient_centre;
			for (var i = 0; i != betas_size; ++i, coefficient_centre += coefficient_centre_stepsize) {
				var y_value = canvas_height - coefficients[i].normalised_value * coefficients_value_scaler - canvas_painter_type.comparative_chart_coeff_center_y_padding + font_offset;
				context.fillText(beta_text + number_to_subscript_string(i + 1), coefficient_centre - beta_char_half_width, y_value);
	 
			}
		}
		}
	}

	switch (model_id) {
	case 2:
	case 3:
	case 4:
	{
		var max_painted_coefficient_value = 1;
		for (var i = 0; i != betas_size; ++i) {

			var variance_normalised_value = coefficients[i + betas_size].normalised_value;

			if (max_painted_coefficient_value < variance_normalised_value)
				max_painted_coefficient_value = variance_normalised_value;

			var top = value_to_y_coord(coefficients[i].normalised_value + canvas_painter_type.normal_trunc * variance_normalised_value);
			var bottom = value_to_y_coord(coefficients[i].normalised_value - canvas_painter_type.normal_trunc * variance_normalised_value);

			var grd = ctx.createLinearGradient(0, top, 0, bottom);

			var steps_size = 10; 
			var color_stop_step = 1.0 / steps_size; 
			var color_stop = 0.0;
			while (color_stop <= 1.0) {
				var distance = (color_stop * canvas_painter_type.normal_trunc * 2 - canvas_painter_type.normal_trunc) ; // / coefficients[i + betas_size].normalised_value; 
				grd.addColorStop(color_stop, "rgba(255, 0, 0, " + 
						.88 * (Math.exp(distance * distance / -2)).toFixed(5) +
						")"); 
				color_stop += color_stop_step;
			}

			coefficients[i].render_top = top;
			coefficients[i].render_bottom = bottom;
			coefficients[i].render_gradient = grd;
		}
	}
	}

	for (var i = 0; i != betas_size; ++i) {
		coefficients[i].render_value_y = value_to_y_coord(coefficients[i].normalised_value);
		coefficients[i].value_interpolator = new value_interpolator_type(0.019, 0.98, 0.0025, 0.0039);
		coefficients[i].value_interpolator.reset(coefficients[i].render_value_y, coefficients[i].render_value_y, 3);
	}
	var coefficient_centre_stepsize = canvas_painter_type.coefficient_circle_radius * 2 + canvas_painter_type.coefficient_circle_padding;

	var interpolated = true;
	function do_paint() 
	{
		ctx.fillStyle = "#000000";
		ctx.strokeStyle = "#000000";
		ctx.lineWidth = 0.5;

		interpolated = true;
		for (var i = 0; i < betas_size; ++i) {
			coefficients[i].value_interpolator.ping(repainting_timer_duration);
			if (coefficients[i].value_interpolator.is_done() == false)
				interpolated = false;
		}

		ctx.beginPath();
		ctx.strokeStyle = "darkred";
		ctx.lineWidth = 3;
		coefficient_centre = canvas_painter_type.coefficient_circle_radius;
		for (var i = 0; i != betas_size; ++i, coefficient_centre += coefficient_centre_stepsize) {
			ctx.moveTo(coefficient_centre - canvas_painter_type.coefficient_circle_radius, coefficients[i].render_value_y);
			ctx.lineTo(coefficient_centre + canvas_painter_type.coefficient_circle_radius, coefficients[i].render_value_y);
		}
		ctx.stroke();
		ctx.beginPath();

		ctx.strokeStyle = "blue";
		ctx.lineWidth = 1.7;
		ctx.beginPath();
		ctx.moveTo(canvas_painter_type.coefficient_circle_radius, coefficients[0].value_interpolator.get_current_value());
		var coefficient_centre = canvas_painter_type.coefficient_circle_radius * 3 + canvas_painter_type.coefficient_circle_padding;
		for (var i = 1; i < betas_size; ++i, coefficient_centre += coefficient_centre_stepsize)
			ctx.lineTo(coefficient_centre, coefficients[i].value_interpolator.get_current_value());
		ctx.stroke();
		ctx.closePath();

		coefficient_centre = canvas_painter_type.coefficient_circle_radius;
		for (var i = 0; i != betas_size; ++i, coefficient_centre += coefficient_centre_stepsize) {
			switch (model_id) {
			case 2:
			case 3:
			case 4:
			{
				var grd = ctx.createRadialGradient(coefficient_centre, coefficients[i].value_interpolator.get_current_value(), 1, coefficient_centre, coefficients[i].value_interpolator.get_current_value(), canvas_painter_type.coefficient_circle_radius * 1.2);
				grd.addColorStop(0, "rgba(0, 250, 250, 0.5)");
				grd.addColorStop(1, "rgba(0, 250, 250, 0)");
				ctx.fillStyle = grd;
				ctx.beginPath();
				ctx.arc(coefficient_centre, coefficients[i].value_interpolator.get_current_value(), canvas_painter_type.coefficient_circle_radius * 1.2, 0, two_pi);
				ctx.fill();
				ctx.closePath();
			}
			default:
			ctx.fillStyle = "#ffffff";
			ctx.beginPath();
			ctx.arc(coefficient_centre, coefficients[i].value_interpolator.get_current_value(), canvas_painter_type.coefficient_circle_radius * .2, 0, two_pi);
			ctx.fill();
			ctx.closePath();
			}
		}

		ctx.closePath();
	}

	function do_paint_all()
	{
			ctx.clearRect(0, 0, canvas.width, canvas_painter_type.canvas_height);

			ctx.fillStyle = "#aaaaff";
			var coefficient_centre = canvas_painter_type.coefficient_circle_radius;
			//ctx.beginPath();
			for (var i = 0; i != betas_size; ++i, coefficient_centre += coefficient_centre_stepsize) {
				ctx.fillStyle = coefficients[i].render_gradient;
				ctx.fillRect(coefficient_centre - canvas_painter_type.coefficient_circle_radius, coefficients[i].render_top, canvas_painter_type.coefficient_circle_radius * 2, coefficients[i].render_bottom - coefficients[i].render_top);
				//ctx.closePath();
			}
			do_paint();
	}

	this.reset_repainting = function()
	{
		interpolated = false;
		reselect_target_interpolation_value();
	}

	function reselect_target_interpolation_value()
	{
		for (var i = 0; i < betas_size; ++i) {
			var from = coefficients[i].value_interpolator.get_current_value();
			var to = value_to_y_coord(coefficients[i].normalised_value + normals[(i + normals_i * betas_size) % normals.length] * coefficients[i + betas_size].normalised_value);
			var tmp = from > to ? 3 : -3;
			coefficients[i].value_interpolator.reset(from, to, tmp);
		}
	}

	this.repaint = function() 
	{
		if (repainting_timer_do_paint_hint == true && interpolated == true) 
			reselect_target_interpolation_value();
		if (repainting_timer_do_paint_hint == true || interpolated == false)
			do_paint_all();
		return interpolated;
	}

	if (model_id == 1 || model_id == 5)
		do_paint();
}

function tasks_list_type()
{
	var tasks_list_type_this = this;
	this.gui = document.createElement("table");
	this.gui.className = "centered_table";

	var tr = document.createElement("tr");
	var td = document.createElement("td");
	td.className = "page_title_td";
	td.appendChild(document.createTextNode("LIST OF EXISTING TASKS"));
	tr.appendChild(td);
	this.gui.appendChild(tr);

	var tr = document.createElement("tr");
	var tableHolder = document.createElement("td");
	tableHolder.style.padding = "0px";
	var table = document.createElement("table");
	tableHolder.appendChild(table);
	tr.appendChild(tableHolder);
	this.gui.appendChild(tr);

	tr = document.createElement("tr");
	td = document.createElement("td");
	this.comparison_canvas_holder = document.createElement("div");
	this.comparison_canvas_holder.id = "overflowish";
	this.comparison_canvas_holder.style.maxWidth = (0.95 * document.documentElement.clientWidth) + "px";
	this.comparison_canvas_holder.style.display = "none";
	var comparison_canvas = document.createElement("canvas");
	//this.comparison_canvas_holder.appendChild(document.createTextNode("[comparator of shown-detail tasks]"));
	this.comparison_canvas_holder.appendChild(document.createElement("br"));
	this.comparison_canvas_holder.appendChild(comparison_canvas);
	td.appendChild(this.comparison_canvas_holder);
	tr.appendChild(td);
	this.gui.appendChild(tr);

	function paint_comparison()
	{
		var keys = Object.keys(tasks_list_type_this.existing_detail_showing_tasks);
		if (keys.length) {

			var font_size = 14;
			var terrain_elevation_value_left = font_size + 15;
			var terrain_elevation_value_right = terrain_elevation_value_left + 15; 
			var terrain_elevation_value_middle = terrain_elevation_value_left + (terrain_elevation_value_right - terrain_elevation_value_left) * 0.5;
			var task_name_left = terrain_elevation_value_right + 30;

			var context = comparison_canvas.getContext("2d"); 
			// unicode codes for subscript betas are not, yet, supported in Source Sans Pro"
			context.font = font_size + "px Arimo";

			// find relevant dimension details for all of the labels
			var canvas_inner_height = 200;
			var canvas_height = canvas_inner_height + canvas_painter_type.comparative_chart_y_padding; 
			var canvas_width = 0;
			var max_label_width = 0;
			var tmp_offset = 10;
			var max_normalised_value = 0;
			var min_terrain_elevation_value = Number.MAX_VALUE;
			var max_terrain_elevation_value = -Number.MAX_VALUE;
			var painters = [];
			for (var i = 0; i != keys.length; ++i) {
				var shown_task = tasks_list_type_this.existing_detail_showing_tasks[keys[i]];
				if (shown_task["canvas"]) {
					if (canvas_width < shown_task.canvas.width)
						canvas_width = shown_task.canvas.width;
					var painter = shown_task.canvas.painter;
					painters.push(painter);
					tmp_offset += 17;
					if (canvas_height < tmp_offset)
						canvas_height = tmp_offset;
					var metrics = painter.get_task_name_metrics(context);
					if (max_label_width < metrics.width)
						max_label_width = metrics.width;
					if (max_normalised_value < painter.get_max_normalised_value())
						max_normalised_value = painter.get_max_normalised_value();
					var terrain_elevation_value = painter.get_terrain_elevation_value();
					if (terrain_elevation_value < min_terrain_elevation_value)
						min_terrain_elevation_value = terrain_elevation_value;
					if (terrain_elevation_value > max_terrain_elevation_value)
						max_terrain_elevation_value = terrain_elevation_value;
				}
			}
			painters.sort(function(a, b) { return a.get_terrain_elevation_value() - b.get_terrain_elevation_value()} );

			if (max_normalised_value > 0) {

				// unicode codes for subscript betas are not, yet, supported in Source Sans Pro"
				context.font = "italic " + font_size + "px Arimo"; 
				var tmp_label = "tasks";
				var tmp_width = context.measureText(tmp_label).width;
				if (max_label_width < tmp_width)
					max_label_width = tmp_width;
				var tmp_offset = (max_label_width - tmp_width) * .5;

				var task_name_right = task_name_left + max_label_width;
				var coefficients_left = task_name_right + 30;
				var norm_coeffs_label_left = canvas_width + coefficients_left + 5;

				canvas_width = norm_coeffs_label_left + font_size;


				comparison_canvas.width = canvas_width;
				comparison_canvas.height = canvas_height;
				context.clearRect(0, 0, canvas_width, canvas_height);

				// unicode codes for subscript betas are not, yet, supported in Source Sans Pro"
				context.font = "italic " + font_size + "px Arimo"; 

				context.fillText(tmp_label, task_name_left + tmp_offset, canvas_height);

				tmp_label = "terrain elevation";
				tmp_width = context.measureText(tmp_label).width;
				tmp_offset = (canvas_height - tmp_width) * .5;
				context.save();
				context.rotate(-half_pi);
				context.fillText(tmp_label, tmp_offset - canvas_height, font_size);
				context.restore();
				tmp_label = "normalised coefficients";
				tmp_width = context.measureText(tmp_label).width;
				tmp_offset = (canvas_height - tmp_width) * .5;
				context.save();
				context.rotate(half_pi);
				context.fillText(tmp_label, tmp_offset, -norm_coeffs_label_left);
				context.restore();

				// execute the painting call...
				var terrain_elevation_value_range = max_terrain_elevation_value - min_terrain_elevation_value;
				var terrain_elevation_value_scaler = terrain_elevation_value_range ? canvas_inner_height / terrain_elevation_value_range : 0;
				var coefficients_value_scaler = canvas_inner_height / max_normalised_value;
				var intensity_step;
				if (painters.length > 1)
					intensity_step = 1 / (painters.length - 1);
				var intensity_value = 0;
				var hue_from = 0;
				var hue_to = 1;
				var hue_step = (hue_to - hue_from) * intensity_step;
				var hue = hue_from;
				context.lineWidth = 1.5;

				tmp_offset = font_size + 8;
				for (var i = 0; i != painters.length; ++i, hue += hue_step, intensity_value += intensity_step) {
					var rgb_scale = 255 * intensity_value;
					var rgb_color = "rgb(";
					var r, g, b;
					var x = Math.floor(hue * 6);
					var f = hue * 6 - x;
					var q = (1 - f);
					switch (x % 6) {
					case 0: 
						rgb_color += parseInt(rgb_scale) + ',' + parseInt(rgb_scale * f) + ",0)";
						break;
					case 1: 
						rgb_color += parseInt(rgb_scale * q) + ',' + parseInt(rgb_scale) + ",0)";
						break;
					case 2: 
						rgb_color += "0," + parseInt(rgb_scale) + ',' + parseInt(rgb_scale * f) + ')';
						break;
					case 3: 
						rgb_color += "0," + parseInt(rgb_scale * q) + ',' + parseInt(rgb_scale) + ')';
						break;
					case 4: 
						rgb_color += parseInt(rgb_scale * f) + ",0," + parseInt(rgb_scale) + ')';
						break;
					case 5: 
						rgb_color += parseInt(rgb_scale) + ",0," + parseInt(rgb_scale * q) + ')';
						break;
					}

					// unicode codes for subscript betas are not, yet, supported in Source Sans Pro"
					context.font = font_size + "px Arimo";
					context.strokeStyle = rgb_color;
					context.fillStyle = rgb_color;

					painters[i].paint_comparison(context, tmp_offset, font_size, terrain_elevation_value_left, terrain_elevation_value_middle, terrain_elevation_value_right, task_name_left, task_name_right, coefficients_left, min_terrain_elevation_value, terrain_elevation_value_scaler, coefficients_value_scaler, canvas_height);

					tmp_offset += 17;
				}

				tasks_list_type_this.comparison_canvas_holder.style.display = "block";
				return;
			}
		} 
		tasks_list_type_this.comparison_canvas_holder.style.display = "none";

	} // paint_comparison

	tr = document.createElement("tr");
	td = document.createElement("td");

	var refresh_button = document.createElement("button");
	refresh_button.className = "full_width";
	refresh_button.appendChild(document.createTextNode("Refresh/reload contents"));
	refresh_button.onclick = function () 
	{
		populate_pre();
		populate();
	}
	td.appendChild(refresh_button);

	var hide_all_details_button = document.createElement("button");
	hide_all_details_button.className = "full_width";
	hide_all_details_button.appendChild(document.createTextNode("Hide all details"));
	hide_all_details_button.onclick = function () 
	{
		for (var keys = Object.keys(tasks_list_type_this.existing_detail_showing_tasks); keys.length; keys = Object.keys(tasks_list_type_this.existing_detail_showing_tasks)) {
			var checkbox = tasks_list_type_this.existing_detail_showing_tasks[keys[0]].checkbox;
			checkbox.checked = false;
			checkbox.onchange();
		}
		tasks_list_type_this.filtered_existing_detail_showing_tasks = {};
		tasks_list_type_this.filtered_existing_detail_showing_animated_tasks = {};
	}
	td.appendChild(hide_all_details_button);

	var main_menu_button = document.createElement("button");
	main_menu_button.className = "full_width";
	main_menu_button.appendChild(document.createTextNode("Main Menu"));
	main_menu_button.onclick = function () 
	{
		main_menu.show();
	}
	td.appendChild(main_menu_button);


	tr.appendChild(td);
	this.gui.appendChild(tr);

	this.show = function()
	{
		if (this.gui != last_div) {
			document.body.replaceChild(this.gui, last_div);
			last_div = this.gui;
			populate_pre();
			populate();
		}
	}

	var waiting_animation_td = document.createElement("td");
	waiting_animation_td.style.borderWidth = "0px";
	var waiting_animation = new waiting_animation_type(waiting_animation_td);

	function replace_table(x)
	{
		waiting_animation.stop();
		tableHolder.replaceChild(x, table);
		table = x;
	}

	function display_status(error)
	{
		var tbl = document.createElement("table");
		tbl.className = "full_width";
		tbl.style.borderWidth = "0px";
		var tr = document.createElement("tr");
		var td = document.createElement("td");
		td.innerHTML = error;
		td.className = "debug_log_from_server";
		tr.appendChild(td);
		tbl.appendChild(tr);
		replace_table(tbl);
	}

	var filter_by = "";

	function blahblah(obj)
	{
		subtask_i = 0;

		for (var i = 0; i != obj.tasks.length;) {

			var decomposed_name = obj.tasks[i].name.split(/[_\-x]/g);
			obj.tasks[i].task_id = parseInt(decomposed_name[0]);
			obj.tasks[i].model_id = parseInt(decomposed_name[1]);

			// transform the tasks with multi-logit models
			if (obj.tasks[i].model_id == 5 && obj.tasks[i].coefficients) {

				var coefficients = obj.tasks[i].coefficients;
				var betas_sets_size = obj.tasks[i].user_data.betas_sets_size;
				var coefficients_per_betas_set = coefficients.length / betas_sets_size;
				var subtasks = [];

				var slice_begin = 0;
				for (var betas_set_i = 0; betas_set_i != betas_sets_size; ++betas_set_i) {

					var subtask = new Object;
					subtask.name = obj.tasks[i].name;
					subtask.task_id = obj.tasks[i].task_id;
					subtask.model_id = obj.tasks[i].model_id;
					subtask.subtask_i = betas_set_i;
					subtask.state = obj.tasks[i].state;
					subtask.short_description = obj.tasks[i].short_description;
					subtask.value = obj.tasks[i].value;

					var slice_end = slice_begin + coefficients_per_betas_set;
					subtask.coefficients = coefficients.slice(slice_begin + 1, slice_end);
					subtask.coefficients.push(coefficients[slice_begin]);

					subtasks.push(subtask);
					slice_begin = slice_end;
				}

				var args = [i, 1].concat(subtasks);
				Array.prototype.splice.apply(obj.tasks, args)

				i += betas_sets_size; 

			} else 
				obj.tasks[i++].subtask_i = 0;
		}

		post_blahblah(obj);
	}

	function post_blahblah(obj)
	{
		var tbl = document.createElement("table");
		tbl.className = "full_width";
		var tr; 
		var td;

		var inpt_size = obj.tasks.length / 10 + 2;

		var new_task_names_set = {};

		var filtered_existing_detail_showing_tasks = tasks_list_type_this.filtered_existing_detail_showing_tasks;
		var filtered_existing_detail_showing_animated_tasks = tasks_list_type_this.filtered_existing_detail_showing_animated_tasks;
		tasks_list_type_this.filtered_existing_detail_showing_tasks = {};
		tasks_list_type_this.filtered_existing_detail_showing_animated_tasks = {};

		var prev_task_completed = false;
		var alternating_display = 0;
		var task_list_position = 0;
		for (var i = 0; i != obj.tasks.length; ++i) {

			var subtask_i = obj.tasks[i].subtask_i;
			if (!subtask_i)
				++task_list_position;

			var tmp_task_completed = (obj.tasks[i].state == "completed" ? true : false);

			if (tmp_task_completed == true && prev_task_completed == false) {
				prev_task_completed = true;

				var filter_row = document.createElement("tr");
				var filter_td = document.createElement("td");
				filter_td.colSpan = 5;
				filter_td.className = "debug_log_to_server";
				filter_td.appendChild(document.createTextNode("filter completed tasks: "));
				var filter_text = document.createElement("input");
				filter_text.size = inpt_size;
				filter_text.size = 30;
				filter_text.value = filter_by;
				filter_text.onchange = function()
				{
					filter_by = this.value.trim();
					post_blahblah(obj);
				}
				filter_td.appendChild(filter_text);
				filter_row.appendChild(filter_td);
				tbl.appendChild(filter_row);
			}

			var tmp_tasksubtask_name = obj.tasks[i].name + '_' + subtask_i;

			if (tmp_task_completed == true && filter_by.length && obj.tasks[i].short_description.search(new RegExp("\\b" + filter_by + "\\b", "i")) == -1) {
				var existing_detail_showing_task = tasks_list_type_this.existing_detail_showing_tasks[tmp_tasksubtask_name];
				if (existing_detail_showing_task) {
					tasks_list_type_this.filtered_existing_detail_showing_tasks[tmp_tasksubtask_name] = existing_detail_showing_task;
					delete tasks_list_type_this.existing_detail_showing_tasks[tmp_tasksubtask_name];
				}
				var existing_detail_showing_animated_task = tasks_list_type_this.existing_detail_showing_animated_tasks[tmp_tasksubtask_name];
				if (existing_detail_showing_animated_task) {
					tasks_list_type_this.filtered_existing_detail_showing_animated_tasks[tmp_tasksubtask_name] = existing_detail_showing_animated_task;
					delete tasks_list_type_this.existing_detail_showing_animated_tasks[tmp_tasksubtask_name];
				}
				continue;
			} else {
				var filtered_existing_detail_showing_task = filtered_existing_detail_showing_tasks[tmp_tasksubtask_name];
				if (filtered_existing_detail_showing_task)
					tasks_list_type_this.existing_detail_showing_tasks[tmp_tasksubtask_name] = filtered_existing_detail_showing_task;
				var filtered_existing_detail_showing_animated_task = filtered_existing_detail_showing_animated_tasks[tmp_tasksubtask_name];
				if (filtered_existing_detail_showing_animated_task)
					tasks_list_type_this.existing_detail_showing_animated_tasks[tmp_tasksubtask_name] = filtered_existing_detail_showing_animated_task;
				++alternating_display;
			}

			function individual_task_stub() 
			{
				var odd_even = alternating_display % 2;
				var task_name = obj.tasks[i].name;
				var tasksubtask_name = tmp_tasksubtask_name;
				var short_description = obj.tasks[i].short_description;
				var task_state = obj.tasks[i].state;
				var task_completed = tmp_task_completed;
				var task_id = obj.tasks[i].task_id;
				var model_id = obj.tasks[i].model_id;
				var model_name = "";

				switch (model_id) {
				case 1:
				model_name = "Logit";
				break;
				case 2:
				model_name = "MixL";
				break;
				case 3:
				model_name = "GMNL-II";
				break;
				case 4:
				model_name = "Gmnl2a";
				break;
				case 5:
				model_name = "MultiL"+ '[' + (subtask_i + 1) + ']';
				break;
				}

				var meta_text;
				if (obj.meta_text && !i)
					meta_text = obj.meta_text;
				else 
					meta_text = null;
				
				var coefficients, terrain_elevation_value;
				if (obj.tasks[i].coefficients) {
					coefficients = obj.tasks[i].coefficients;
					terrain_elevation_value = obj.tasks[i].value; 
				} else
					coefficients = terrain_elevation_value = null;

				var td;

				new_task_names_set[tasksubtask_name] = true;

				var header_row = document.createElement("tr");
				if (odd_even)
					header_row.className = "task_order_column_alt";
				else
					header_row.className = "task_order_column";
				

				// quick-hack (temporary testing of GUI listing textual discription all the time, even when in the collapsed/tabled mode)
				if (!subtask_i) { // short description

					var short_description_container = document.createElement("td");
					short_description_container.colSpan = 5;

					var short_description_pre = document.createElement("pre");
					short_description_pre.className = "help_content_fieldname";
					short_description_pre.style.display="inline";

					var first_line_short_description_index = short_description.indexOf('\n');
					var first_line_short_description = short_description.substring(0, first_line_short_description_index != -1 ? Math.min(first_line_short_description_index, 30) : 30) + ' ';

					short_description_pre.appendChild(document.createTextNode(first_line_short_description));
					short_description_container.appendChild(short_description_pre);
					short_description_container.appendChild(document.createTextNode(" ("));

					var short_description_label = document.createElement("label");
					short_description_label.appendChild(document.createTextNode("more..."));
					short_description_label.className = "extra_option_text";
					short_description_label.style.textDecoration = "underline";

					short_description_container.appendChild(short_description_label);
					short_description_container.appendChild(document.createTextNode(')'));

					short_description_label.is_expanded = false;
					short_description_label.onclick = function ()
					{
						if (this.is_expanded == false) {
							this.is_expanded = true;
							short_description_label.replaceChild(document.createTextNode("less..."), short_description_label.firstChild);
							short_description_pre.className = "extra_option_text";
							short_description_pre.replaceChild(document.createTextNode(short_description), short_description_pre.firstChild);
						} else {
							this.is_expanded = false;
							short_description_label.replaceChild(document.createTextNode("more..."), short_description_label.firstChild);
							short_description_pre.className = "help_content_fieldname";
							short_description_pre.replaceChild(document.createTextNode(first_line_short_description), short_description_pre.firstChild);
						}
					}

					header_row.appendChild(short_description_container);
					tbl.appendChild(header_row);
				}

				header_row = document.createElement("tr");
				if (odd_even)
					header_row.className = "task_order_column_alt";
				else
					header_row.className = "task_order_column";

				//{ task position/order control
				if (task_completed == false) {
					td = document.createElement("td");
					td.style.borderTopWidth = "0px";
					if (!subtask_i) {
						var inpt = document.createElement("input");
						//inpt.type = "number";
						inpt.size = inpt_size;
						inpt.className = "debug_log_to_server";
						inpt.size = 3;
						var old_value = task_list_position;
						inpt.title = "To change task's position in the list -- enter new position number and press enter";
						inpt.value = task_list_position;
						inpt.onchange = function ()
						{
							var this_value = parseInt(this.value);
							if (isNaN(this_value) == true) {
								alert("Oooohh, the value " + this.value + " is really not right, now is it?");
								return;
							}
							this.disabled = true;
							var form = new FormData();
							form.append("--task_name", task_name);
							form.append("--steps_to_move_by", this_value - old_value);
							var spurious_try_again_flag = true;
							http_request = new XMLHttpRequest();
							http_request.withCredentials = true;

							populate_pre();
							http_request.onreadystatechange = function()
							{
								if (this.readyState == 4) {
									inpt.disabled = false;
									if (this.status == 200) {
										//alert(this.responseText);
										var obj = JSON.parse(this.responseText);
										if (obj.echo) {
											populate();
										} else if (obj.error) {
											display_status("Server says hmmm: " + obj.error);
										}
									} else if (this.status != 0 || spurious_try_again_flag == false) {
										display_status("Epic fail... [specifics are not yet diagnosed properly, the browser-communicated status code is " + this.status + ']');
									} else {
										spurious_try_again_flag = false;
										http_request.open("POST", server_at + "move_task_in_list");
										this.send(form);
									}
								} else if (this.readyState == 0) {
									inpt.disabled = false;
								}
							}
							http_request.open("POST", server_at + "move_task_in_list");
							http_request.send(form);
						}
						td.appendChild(inpt);
					}
					header_row.appendChild(td);
				}
				//}

				td = document.createElement("td");
				td.appendChild(document.createTextNode("ID=" + task_id + " (" + model_name + ')'));
				if (task_completed == true)
					td.colSpan = 2;
				header_row.appendChild(td);

				//{ show details control
				td = document.createElement("td");
				var label = document.createElement("label");
				label.className = "help_content_fieldname";
				label.appendChild(document.createTextNode("show details"));
				var show_details_checkbox = document.createElement("input");
				show_details_checkbox.type = "checkbox";
				if (tasks_list_type_this.existing_detail_showing_tasks[tasksubtask_name])
					show_details_checkbox.checked = true;
				else
					show_details_checkbox.checked = false;
				show_details_checkbox.onchange = function()
				{
					if (this.checked == true) {
						var tr = document.createElement("tr");
						if (odd_even)
							tr.className = "task_order_column_alt";
						else
							tr.className = "task_order_column";
						var td = document.createElement("td");
						//td.className = "centered_td";
						td.colSpan = 5;

						if (meta_text) {
							var div = document.createElement("div");
							div.className = "active_task_meta_text";
							div.appendChild(document.createTextNode(meta_text));
							//div.innerHTML = "<pre class='active_task_meta_text'>" + meta_text + "\n(do not try to click/reload all the bloody time as numbers may update rarely -- like in a few minutes or so)</pre>";
							td.appendChild(div);
						}


						if (coefficients) {

							var calculate_normalised_betas = function(coefficients, begin, end)
							{
								var max = -Number.MAX_VALUE;
								var min = Number.MAX_VALUE;
									for (var i = begin; i != end; ++i) {
										if (coefficients[i].value > max)
											max = coefficients[i].value;
										if (coefficients[i].value < min)
											min = coefficients[i].value;
									}
								var inv_distance;
								if (max != min)
									inv_distance = 1.0 / (max - min);
								else
									inv_distance = 1;
								for (var i = begin; i != end; ++i) { 
									coefficients[i].normalised_value = (coefficients[i].value - min) * inv_distance;
								}
								return inv_distance;
							}
							var generate_headings = function(txt, tr_, betas_size, post_txt) 
							{
								for (var i = 0; i != betas_size; ++i) {
									td_ = document.createElement("td");
									td.className = "help_content_title";
									td_.innerHTML = txt + "<sub>" + (i + 1) + "</sub>" + post_txt;
									tr_.appendChild(td_);
								}
							}

							var tbl_ = document.createElement("table");
							tbl_.className = "full_width";

							var tr_ = document.createElement("tr");

							var td_ = document.createElement("td");
							td_.className = "terrain_elevation_value";

							var betas_size = 0;
							var inv_distance;
							function display_float(x)
							{
								return parseFloat(parseFloat(x).toFixed(3));
							}
							switch (model_id) {
							case 1:
								td_.appendChild(document.createTextNode("Log-likelihood: -" + display_float(terrain_elevation_value)));
								tr_.appendChild(td_);
								betas_size = coefficients.length;
								calculate_normalised_betas(coefficients, 0, betas_size);
								generate_headings("<b>&beta;</b>", tr_, betas_size, "");
							break;
							case 2:
								td_.appendChild(document.createTextNode("Log-likelihood: -" + display_float(terrain_elevation_value)));
								tr_.appendChild(td_);
								betas_size = coefficients.length / 2;
								inv_distance = calculate_normalised_betas(coefficients, 0, betas_size);
								for (var i = 0; i != betas_size; ++i)
									coefficients[i + betas_size].normalised_value = coefficients[i + betas_size].value * inv_distance;
								generate_headings("<b>&beta;</b>", tr_, betas_size, "");
								generate_headings("<b>&sigma;</b><sub>&beta;", tr_, betas_size, "</sub>");
							break;
							case 3:
								td_.appendChild(document.createTextNode("Log-likelihood: -" + display_float(terrain_elevation_value)));
								tr_.appendChild(td_);
								betas_size = (coefficients.length - 1) / 2;
								inv_distance = calculate_normalised_betas(coefficients, 0, betas_size);
								for (var i = 0; i != betas_size; ++i)
									coefficients[i + betas_size].normalised_value = coefficients[i + betas_size].value * inv_distance;
								generate_headings("<b>&beta;</b>", tr_, betas_size, "");
								generate_headings("<b>&sigma;</b><sub>&beta;", tr_, betas_size, "</sub>");
								td_ = document.createElement("td");
								td_.innerHTML = "&tau;";
								tr_.appendChild(td_);
							break;
							case 4: {
								td_.appendChild(document.createTextNode("Log-likelihood: -" + display_float(terrain_elevation_value)));
								tr_.appendChild(td_);
								betas_size = (coefficients.length - 4) / 2;
								var phi = coefficients[coefficients.length - 1].value;
								inv_distance = calculate_normalised_betas(coefficients, 0, betas_size);
								for (var i = 0; i != betas_size; ++i)
									coefficients[i + betas_size].normalised_value = coefficients[i + betas_size].value * inv_distance;
								generate_headings("<b>&beta;</b>", tr_, betas_size, "");
								generate_headings("<b>&sigma;</b><sub>&beta;", tr_, betas_size, "</sub>");
								td_ = document.createElement("td");
								td_.innerHTML = "&tau;";
								tr_.appendChild(td_);
								td_ = document.createElement("td");
								td_.innerHTML = "<i>&mu;(&Phi;)</i>";
								tr_.appendChild(td_);
								td_ = document.createElement("td");
								td_.innerHTML = "&sigma;<sub><i>&Phi;</i></sub>";
								tr_.appendChild(td_);
								td_ = document.createElement("td");
								td_.innerHTML = "&rho;<sub>&tau;<i>&Phi;</i></sub>";
								tr_.appendChild(td_);
							}
							break;
							case 5:
								td_.appendChild(document.createTextNode("Log-likelihood (for all classes): -" + display_float(terrain_elevation_value)));
								tr_.appendChild(td_);
								betas_size = coefficients.length - 1;
								calculate_normalised_betas(coefficients, 0, betas_size);
								generate_headings("<b>&beta;</b>", tr_, betas_size, "");
								td_ = document.createElement("td");
								td_.innerHTML = "&tau;";
								tr_.appendChild(td_);
							break;
							default:
								td_.appendChild(document.createTextNode("Terrain minimisation: " + display_float(terrain_elevation_value)));
								tr_.appendChild(td_);
							break;
							}
							tbl_.appendChild(tr_);

							tr_ = document.createElement("tr");
							td_ = document.createElement("td");
							if (task_completed == false)
								td_.className = "incomplete_value";
							td_.appendChild(document.createTextNode("Range"));
							tr_.appendChild(td_);
							for (var i = 0; i != coefficients.length; ++i) {
								td_ = document.createElement("td");
								if (task_completed == false)
									td_.className = "incomplete_value";
								td_.appendChild(document.createTextNode(display_float(coefficients[i].range)));
								tr_.appendChild(td_);
							}
							tbl_.appendChild(tr_);

							tr_ = document.createElement("tr");
							td_ = document.createElement("td");
							td_.appendChild(document.createTextNode("Raw value"));
							tr_.appendChild(td_);
							for (var i = 0; i != coefficients.length; ++i) {
								td_ = document.createElement("td");
								td_.appendChild(document.createTextNode(display_float(coefficients[i].value)));
								tr_.appendChild(td_);
							}
							tbl_.appendChild(tr_);

							tr_ = document.createElement("tr");
							td_ = document.createElement("td");
							if (task_completed == true)
								td_.className = "normalised_value";
							else
								td_.className = "incomplete_normalised_value";
							td_.appendChild(document.createTextNode("Normalised value"));

							td_.appendChild(document.createElement("br"));
							var checkbox = document.createElement("input");
							checkbox.type = "checkbox";
							var label = document.createElement("label");
							label.appendChild(document.createTextNode("(animate"));
							label.appendChild(checkbox);
							label.appendChild(document.createTextNode(")"));
							td_.appendChild(label);

							tr_.appendChild(td_);
							for (var i = 0; i != coefficients.length; ++i) {
								td_ = document.createElement("td");
								if (coefficients[i]["normalised_value"] != null) {
									if (task_completed == true)
										td_.className = "normalised_value";
									else
										td_.className = "incomplete_normalised_value";
									td_.appendChild(document.createTextNode(display_float(coefficients[i].normalised_value)));
								}
								tr_.appendChild(td_);
							}
							tbl_.appendChild(tr_);

							var overflow_holder_1 = document.createElement("div");
							overflow_holder_1.id = "overflowish";
							overflow_holder_1.style.maxWidth = (0.95 * document.documentElement.clientWidth) + "px";
							overflow_holder_1.appendChild(tbl_);
							td.appendChild(overflow_holder_1);

							var canvas = document.createElement("canvas");
							canvas.painter = new canvas_painter_type(canvas, terrain_elevation_value, coefficients, task_id, model_id, model_name, betas_size);

							var overflow_holder_2 = document.createElement("div");
							overflow_holder_2.style.display = "none";
							overflow_holder_2.id = "overflowish";
							overflow_holder_2.style.maxWidth = (0.95 * document.documentElement.clientWidth) + "px";
							overflow_holder_2.appendChild(document.createElement("br"));
							overflow_holder_2.appendChild(canvas);
							td.appendChild(overflow_holder_2);

							checkbox.onchange = function()
							{
								if (this.checked == true) {
									overflow_holder_2.style.display = "block";
									switch (model_id) {
									case 1:
									case 5:
									break;
									default:
									tasks_list_type_this.existing_detail_showing_animated_tasks[tasksubtask_name] = canvas;
									if (repainting_timer == null)
										repainting_timer = request_animation_frame(timer_callback);
									canvas.painter.reset_repainting();
									reset_repainting_timer_repaints();
									}
								} else {
									overflow_holder_2.style.display = "none";
									delete tasks_list_type_this.existing_detail_showing_animated_tasks[tasksubtask_name];
								}
							}
							if (tasks_list_type_this.existing_detail_showing_animated_tasks[tasksubtask_name]) {
								checkbox.checked = true;
								checkbox.onchange();
							} else
								checkbox.checked = false;

							tasks_list_type_this.existing_detail_showing_tasks[tasksubtask_name] = { "canvas" : canvas , "divs" : [ overflow_holder_1, overflow_holder_2 ], "checkbox" : show_details_checkbox }
						} else {
							td.className = "coefficients_not_ready";
							td.appendChild(document.createTextNode("Nothing is ready as of yet (convergence has not proceeded enough)..."));
							td.appendChild(document.createElement("br"));
							td.appendChild(document.createTextNode("Try again in a few minutes."));

							tasks_list_type_this.existing_detail_showing_tasks[tasksubtask_name] = {};
							delete tasks_list_type_this.existing_detail_showing_animated_tasks[tasksubtask_name];
						}
						tr.appendChild(td);
						tbl.insertBefore(tr, header_row.nextSibling);
					} else {
						delete tasks_list_type_this.existing_detail_showing_tasks[tasksubtask_name];
						delete tasks_list_type_this.existing_detail_showing_animated_tasks[tasksubtask_name];
						//alert("Not yet implemented");
						tbl.removeChild(header_row.nextSibling);
					}
					paint_comparison();
				}
				label.appendChild(show_details_checkbox);
				td.appendChild(label);
				header_row.appendChild(td);
				//}

				//{ status display
				td = document.createElement("td");
				if (task_state == "active")
					td.className = "active_task_label";
				else if (task_state == "pending") 
					td.className = "pending_task_label";
				else
					td.className = "complete_task_label";
				td.appendChild(document.createTextNode(task_state));
				header_row.appendChild(td);
				//}

				//{ delete button
				td = document.createElement("td");
				var delete_button = document.createElement("button");
				delete_button.appendChild(document.createTextNode("delete"));
				delete_button.onclick = function ()
				{
					if (confirm("About to delete (all) task(s) with ID=" + task_id + "\nDO YOU WANT TO PROCEED?") == true) {
						var spurious_try_again_flag = true;
						this.disabled = true;
						var form = new FormData();
						form.append("--task_name", task_name);
						http_request = new XMLHttpRequest();
						http_request.withCredentials = true;

						populate_pre();
						http_request.onreadystatechange = function()
						{
							if (this.readyState == 4) {
								delete_button.disabled = false;
								if (this.status == 200) {
									//alert(this.responseText);
									var obj = JSON.parse(this.responseText);
									if (obj.echo) {
										populate();
									} else if (obj.error) {
										display_status("Server says hmmm: " + obj.error);
									}
								} else if (this.status != 0 || spurious_try_again_flag == false) {
									display_status("Epic fail... [specifics are not yet diagnosed properly, the browser-communicated status code is " + this.status + ']');
								} else {
									spurious_try_again_flag = false;
									http_request.open("POST", server_at + "delete_task");
									this.send(form);
								}
							} else if (this.readyState == 0) {
								delete_button.disabled = false;
							}
						}
						http_request.open("POST", server_at + "delete_task");
						http_request.send(form);
					}
				}
				td.appendChild(delete_button);
				header_row.appendChild(td);
				//}

				tbl.appendChild(header_row);

				if (show_details_checkbox.checked == true)
					show_details_checkbox.onchange();
			}
			new individual_task_stub();
		}
		replace_table(tbl);

		// clean the existing set of 'detail-showing tasks'
		var existing_detail_showing_tasks = Object.keys(tasks_list_type_this.existing_detail_showing_tasks);
		for (var i = 0; i != existing_detail_showing_tasks.length; ++i)
			if (new_task_names_set[existing_detail_showing_tasks[i]] != true) {
				delete tasks_list_type_this.existing_detail_showing_tasks[existing_detail_showing_tasks[i]];
				delete tasks_list_type_this.existing_detail_showing_animated_tasks[existing_detail_showing_tasks[i]];
			}
		paint_comparison();
	}

	this.existing_detail_showing_tasks = {};
	this.existing_detail_showing_animated_tasks = {};
	this.filtered_existing_detail_showing_tasks = {};
	this.filtered_existing_detail_showing_animated_tasks = {};

	function populate_pre()
	{
		tasks_list_type_this.comparison_canvas_holder.style.display = "none";
		display_status("Please wait, processing<br>(this could take a minute or so...)");
		var tr = document.createElement("tr");
		tr.appendChild(waiting_animation_td);
		waiting_animation.restart();
		table.appendChild(tr);
	}

	function populate()
	{
		/*
		//{ offline testing
		var obj = {};
		obj.tasks = [];
		obj.tasks.length = 8;
		for (var i = 0; i != 5; ++i) {
			obj.tasks[i] = new function() {
				this.value = 11.2 + i;
				this.name = i + "_3-1x2";
				this.short_description = 'this is something blah blah blah\naostu asoetusaoteh asth\nanoetuhnaeothu an\nanotehu\naoneu';
				this.state = "pending";
				this.coefficients = [
					{ value : 0.3 + i * .5 , from : 0.1 , range : 0.5 }, 
					{ value : -0.7 + i , from : -0.8 , range : 0.2 }, 
					{ value : 0.9 + i , from : 0.89 , range : 0.1 }, 
					{ value : 0.1 + i , from : 0.1 , range : 0.1 }, 
					{ value : -0.7 + i , from : -0.8 , range : 0.2 }, 
				];
			}
		}
		for (var i = 5; i != 8; ++i) {
			obj.tasks[i] = new function() {
				this.value = 11.2;
				this.short_description = "this is something blah blah blah";
				this.name = i + "_1-1x2";
				this.state = "completed";
				this.coefficients = [];
				this.coefficients.length = 6;
				//
				//for (var j = 0; j != 5; ++j) {
				//	this.coefficients[j] = new function() {
				//		this.value = j;
				//		this.from = -1;
				//		this.range = j + 1;
				//  }
				//}
				//
				this.coefficients = [
					{ value : 0.3 , from : 0.1 , range : 0.5 }, 
					{ value : -0.7 , from : -0.8 , range : 0.2 }, 
					{ value : 0.9 , from : 0.89 , range : 0.1 }, 
					{ value : 0.1 , from : 0.1 , range : 0.1 }, 
					{ value : -0.7 , from : -0.8 , range : 0.2 }, 
					{ value : 0.7 , from : 0.65 , range : 0.1 }
				];
			}
		}
		obj.meta_text = "processing peers: 3. \nblah blah blah";
		blahblah(obj);
		return;
		//}
		*/

		http_request = new XMLHttpRequest();
		http_request.spurious_try_again_flag = true;
		http_request.withCredentials = true;
		http_request.onreadystatechange = function()
		{
			if (this.readyState == 4) {
				if (this.status == 200) {
					//alert(this.responseText);
					var obj = JSON.parse(this.responseText);
					if (obj.error) {
						display_status("Server says hmmm: " + obj.error);
						return;
					} else if (obj.tasks) {
						blahblah(obj);
						return;
					}
				} else if (this.status != 0 || this.spurious_try_again_flag == false) {
					display_status("Epic fail... [specifics are not yet diagnosed properly, the browser-communicated status code is " + this.status + ']');
				} else {
					this.spurious_try_again_flag = false;
					http_request.open("GET", server_at + "get_tasks_list");
					this.send();
				}
			} 		
		}
		http_request.open("GET", server_at + "get_tasks_list");
		http_request.send();
	}
}

function main_menu_type()
{
	this.gui = document.createElement("div");
	var beta_div = document.createElement("div");
	beta_div.className = "beta";
	beta_div.appendChild(document.createTextNode("Please note: this software is pre-BETA, at times running in slowed-down test/debug mode."));
	beta_div.appendChild(document.createElement("br"));
	beta_div.appendChild(document.createTextNode("Do expect multitude of bugs, SLOW responses, server CRASHES and other nasty surprises."));
	this.gui.appendChild(beta_div);

	var tbl = document.createElement("table");
	tbl.className = "centered_table";
	var tr
	var td;

	tr = document.createElement("tr");
	td = document.createElement("td");
	elem = document.createElement("button");
	elem.className = "full_width";
	elem.appendChild(document.createTextNode("Add a New Task"));
	elem.onclick = function() 
	{
		new_task.show();
	}
	td.appendChild(elem);
	elem = document.createElement("button");
	elem.className = "full_width";
	elem.appendChild(document.createTextNode("Show Existing Tasks"));
	elem.onclick = function () 
	{
		tasks_list.show();
	}
	td.appendChild(elem);
	tr.appendChild(td);
	tbl.appendChild(tr);

	this.gui.appendChild(tbl);

	// autoload font exclusive to canvas (when main font supports unicode subscript betas, then refactor html canvas code to use the main font anyways)
	var hack_1 = document.createElement("div");
	hack_1.className = "hack_1";
	hack_1.appendChild(document.createTextNode("..."));
	this.gui.appendChild(hack_1);

	this.show = function()
	{
		if (this.gui != last_div) {
			document.body.replaceChild(this.gui, last_div);
			last_div = this.gui;
		}
	}
}

function ajdust_max_overflow_widths()
{
	var max_width = (0.95 * document.documentElement.clientWidth) + "px";
	new_task.csv_table_holder.style.maxWidth = max_width;
	tasks_list.comparison_canvas_holder.style.maxWidth = max_width;
	var keys = Object.keys(tasks_list.existing_detail_showing_tasks);
	for (var i = 0; i != keys.length; ++i) {
		var shown_task = tasks_list.existing_detail_showing_tasks[keys[i]];
		if (shown_task["divs"])
			for (var j = 0; j != shown_task.divs.length; ++j)
				shown_task.divs[j].style.maxWidth = max_width;
	}
}

var loading_please_wait_title;
function async_main()
{
	if ("onorientationchange" in window && "orientation" in window)
		window.onorientationchange = ajdust_max_overflow_widths;
	else  
		window.onresize = ajdust_max_overflow_widths;

		normals.length = 200000;
		for (var i = 0; i != normals.length; ++i)
			normals[i] = draw_from_normal();
		document.body.removeChild(loading_please_wait_title);
		batch_fill_context_menu = new batch_fill_context_menu_type();
		tasks_list = new tasks_list_type();
		new_task = new new_task_type(); 
		main_menu = new main_menu_type();
		last_div = main_menu.gui;
		document.body.appendChild(last_div);
}
function main()
{
	var common_style = " button:active { text-shadow: 0px 0px 3px #ffffff; box-shadow: none; color: black; background: #b57edc; /* background: linear-gradient(to bottom,  #b57edc,  #9f00c5); */ background: linear-gradient(to bottom,  #ffffff,  #b57edc); } ";
	if (!navigator.userAgent.match(/(ipad|iphone|ipod|andoid)/i))
		common_style = "button:hover, " + common_style + " button:hover { border-color: #c0c0c0 #b57edc #b57edc #c0c0c0; }";
	var sheet = document.createElement('style')
	sheet.innerHTML = common_style;
	document.body.appendChild(sheet);

	zip.workerScriptsPath = "third_party/zip/";
	var elem = document.createElement("canvas");
	if (request_animation_frame && cancel_animation_frame && window["innerHeight"] != null && window["pageXOffset"] != null && setInterval && clearInterval && Blob && elem && elem["getContext"] != null && File && FileReader && XMLHttpRequest) {
		var ctx = elem.getContext("2d");
		var blob;
		try {
			blob = new Blob;
		} catch(e) {
			blob = null;
		}
		if (ctx != null && ctx["createLinearGradient"] != null && blob != null &&  (blob.slice || blob.webkitSlice)) {
			loading_please_wait_title = document.createElement("div");
			loading_please_wait_title.className = "loading_please_wait";
			loading_please_wait_title.appendChild(document.createTextNode("Loading..."));
			document.body.insertBefore(loading_please_wait_title, document.body.firstChild);
			setTimeout("async_main()", 100);
			return;
		}
	} 
	document.body.innerHTML = "<div class='loading_please_wait'>Unsupported browser.<br>Try using the version of Firefox</div>";
}

var repainting_timer = null;
var repainting_timer_duration = 0;
var repainting_timer_do_paint_hint = true;

var repainting_timer_timestamp = 0;
var repainting_timer_idle_remaining = 0;

function reset_repainting_timer_repaints()
{
	repainting_timer_do_paint_hint = false;
	repainting_timer_idle_remaining = 2000;
}

function timer_callback(now)
{
	repainting_timer = request_animation_frame(timer_callback);
	repainting_timer_duration = now - repainting_timer_timestamp;
	repainting_timer_timestamp = now;
	if (repainting_timer_do_paint_hint == true) {
		repainting_timer_idle_remaining -= repainting_timer_duration; 
		if (repainting_timer_idle_remaining < 0) {
			repainting_timer_idle_remaining = 2000;
			normals_i = ++normals_i % normals.length;
		} else
			return;
	} 
	var keys = Object.keys(tasks_list.existing_detail_showing_animated_tasks);
	if (!keys.length || tasks_list.gui != last_div) {
		cancel_animation_frame(repainting_timer);
		repainting_timer = null;
	} else {
		var tmp = true;
		for (var i = 0; i != keys.length; ++i) {
			var canvas = tasks_list.existing_detail_showing_animated_tasks[keys[i]];
			if (canvas.painter.repaint() == false)
				tmp = false;
		}
		repainting_timer_do_paint_hint = tmp;
	}
}

</script>
<!-- } -->

</head>
<!-- help-text { -->
<body onload="main();" onclick="batch_fill_context_menu.hide();">
<div class="help_content" id="help_model_content">
<br>
Available models: <a href="http://en.wikipedia.org/wiki/Multinomial_logit" target="_blank">Logit</a>, <a href="http://en.wikipedia.org/wiki/Mixed_logit" target="_blank">Mixed logit</a>, <a href="http://www.censoc.uts.edu.au/researchoutput/wp09-002.pdf" target="_blank">GMNL-II</a>, <a href="https://dl.dropbox.com/s/ri2v6k4fagm0hzm/GMNL2a.pdf?token_hash=AAEMQl1t0DMSBNAzUgP0VerakeLb8ixjdRQmQdqABtP7Eg&dl=1" target="_blank">Gmnl2a</a> (although Gmnl2a is currently under a very heavy development and it is very likely indeed that the aforementioned documentation hyperlink will be "out of sync" with the actual code... this should be resolved automatically in due time). 
<p>Wherever applicable: 
<ul>
<li>Normal distribution is used for <b>&sigma;</b><sub>&beta;</sub> (a.k.a. <b>&eta;</b> in some of the aforementioned model-documentation hyperlinks). Such distributions are not covariant (i.e. only a diagonal variance-covariance matrix is used). 
</li>
<li>Custom distribution (similar to lognormal of e^<sup>x</sup>, but not quite) is used for the scale parameter: 
<ul>
<li>1 + x for x &gt; 0 and</li>
<li>1 / (1 - x) for x &lt; 0</li> 
</ul>
where x ~ <i>&Nu;</i>(0, 1)
</li>
<li>
From a mathematical standpoint, <b>&sigma;</b><sub>&beta;</sub> symbol(s) do not denote variance but rather standard deviation: unit normal distribution scaled (widened/narrowed by the <b>&sigma;</b><sub>&beta;</sub>). 
</li>
</ul>
Additionally, Gmnl2a may not preserve the "absolute values ratio" between attributes, nor their relationship with the zero-crossing. Consequently, one may not necessarily benefit from survey analysis which aims at identifying certainty-vs-uncertainty of attributes or attributes' inter-proportional relationship (e.g. willingness to pay, e.g. "division by zero" may occur). What remains is simply a differential relationship (in a normalised, scaled and offset to start from 0 and peak at 1, form) -- i.e. how one attribute is more/less valued with respect to others. An explicit use-case would be to evaluate Gmnl2a model and see if variances (<b>&sigma;</b><sub>&beta;</sub> a.k.a. <b>&eta;</b>) are consistently lower than those obtained from mixed logit analysis, if so then such information can be used to better identify class(es) of respondents with more similar/homogeneous preferences.
<p>See relevant sections of the overall <a href="https://github.com/CenSoC/leon_wip" target="_blank">source-code</a> repository for more details.
</div>
<div class="help_content" id="help_dataset_content" >
File must be in a .CSV (coma separated values) format. Layout requirements are similar to what, in some circles, is known as a "stacked data format". Namely they are:
<ul>
<li>
Each alternative's data is a row.
</li>
<li>
Attributes are stored in columns (a given attribute will be represented by a given column).
</li>
<li>
There must be a <span class="help_content_fieldname">choice</span> column. It must contain 0 (zero) for those alternatives which were not chosen by a respondent, and a 1 (one) denoting the chosen alternative.
</li>
<li>
There must be a <span class="help_content_fieldname">respondent</span> column (indicating which respondent any given row belongs to).
</li>
<li>
There must be a <span class="help_content_fieldname">question</span> (a.k.a. observation or choice-set) column -- grouping relevant alternatives into a given choice set.
</li>
<li>
There must be an <span class="help_content_fieldname">alternative</span> column (with values enumerating alternatives in any given choice set).
</li>
</ul>
<p>
For example, a given dataset may look similar to the following (note: order of columns in the following example is purely coincidental as are the effect-coding of attributes and the order of rows):
<br>
<table style="border-spacing:1px; border-collapse:separate;">
<tr>
<td>Respondent</td>
<td>Choice-Set</td>
<td>Alternative</td>
<td>Atttribute-1</td>
<td>Atttribute-2</td>
<td>Choice</td>
</tr>
<tr><td class="dataset_example_respondent_1">1</td><td class="dataset_example_choiceset_1">1</td><td class="dataset_example_alternative_1">1</td><td>-1</td><td>-1</td><td>0</td></tr>
<tr><td class="dataset_example_respondent_1">1</td><td class="dataset_example_choiceset_1">1</td><td class="dataset_example_alternative_2">2</td><td>1</td><td>-1</td><td>0</td></tr>
<tr><td class="dataset_example_respondent_1">1</td><td class="dataset_example_choiceset_1">1</td><td class="dataset_example_alternative_3">3</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td class="dataset_example_respondent_1">1</td><td class="dataset_example_choiceset_1">1</td><td class="dataset_example_alternative_4">4</td><td>-1</td><td>1</td><td>0</td></tr>
<tr><td class="dataset_example_respondent_1">1</td><td class="dataset_example_choiceset_2">2</td><td class="dataset_example_alternative_1">1</td><td>-1</td><td>-1</td><td>1</td></tr>
<tr><td class="dataset_example_respondent_1">1</td><td class="dataset_example_choiceset_2">2</td><td class="dataset_example_alternative_2">2</td><td>1</td><td>-1</td><td>0</td></tr>
<tr><td class="dataset_example_respondent_1">1</td><td class="dataset_example_choiceset_2">2</td><td class="dataset_example_alternative_3">3</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td class="dataset_example_respondent_1">1</td><td class="dataset_example_choiceset_2">2</td><td class="dataset_example_alternative_4">4</td><td>-1</td><td>1</td><td>0</td></tr>
<tr><td class="dataset_example_respondent_1">1</td><td class="dataset_example_choiceset_3">3</td><td class="dataset_example_alternative_1">1</td><td>-1</td><td>-1</td><td>0</td></tr>
<tr><td class="dataset_example_respondent_1">1</td><td class="dataset_example_choiceset_3">3</td><td class="dataset_example_alternative_2">2</td><td>1</td><td>-1</td><td>0</td></tr>
<tr><td class="dataset_example_respondent_1">1</td><td class="dataset_example_choiceset_3">3</td><td class="dataset_example_alternative_3">3</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td class="dataset_example_respondent_1">1</td><td class="dataset_example_choiceset_3">3</td><td class="dataset_example_alternative_4">4</td><td>-1</td><td>1</td><td>1</td></tr>
<tr><td class="dataset_example_respondent_2">2</td><td class="dataset_example_choiceset_1">1</td><td class="dataset_example_alternative_1">1</td><td>-1</td><td>-1</td><td>1</td></tr>
<tr><td class="dataset_example_respondent_2">2</td><td class="dataset_example_choiceset_1">1</td><td class="dataset_example_alternative_2">2</td><td>1</td><td>-1</td><td>0</td></tr>
<tr><td class="dataset_example_respondent_2">2</td><td class="dataset_example_choiceset_1">1</td><td class="dataset_example_alternative_3">3</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td class="dataset_example_respondent_2">2</td><td class="dataset_example_choiceset_1">1</td><td class="dataset_example_alternative_4">4</td><td>-1</td><td>1</td><td>0</td></tr>
<tr><td class="dataset_example_respondent_2">2</td><td class="dataset_example_choiceset_2">2</td><td class="dataset_example_alternative_1">1</td><td>-1</td><td>-1</td><td>0</td></tr>
<tr><td class="dataset_example_respondent_2">2</td><td class="dataset_example_choiceset_2">2</td><td class="dataset_example_alternative_2">2</td><td>1</td><td>-1</td><td>1</td></tr>
<tr><td class="dataset_example_respondent_2">2</td><td class="dataset_example_choiceset_2">2</td><td class="dataset_example_alternative_3">3</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td class="dataset_example_respondent_2">2</td><td class="dataset_example_choiceset_2">2</td><td class="dataset_example_alternative_4">4</td><td>-1</td><td>1</td><td>0</td></tr>
</table>
<p>
Different respondents may have different number of choice sets. Different choice sets may have different number of alternatives. All rows, however, must have the same attributes.
<p>Moreover, following restrictions apply to the values in various columns:
<ul>
<li>
The respondent/choice-set/alternative columns may contain alphanumeric values
</li>
<li>
The attribute columns may only contain numbers (although decimal values are allowed)
</li>
<li>
The choice column may only be either 0 or 1
</li>
</ul>
<p>
<span class="help_content_fieldname">Preview rows</span> allows one to specify how many rows (from dataset file selected in the <span class="help_content_fieldname">.CSV file</span> field) will be displayed in the interactive column-selector table. This may be of help when selecting designated elements of the .CSV dataset (i.e. which column has respondent id, where is a choice column, etc.)
<p>
Many data files will have title row(s). <span class="help_content_fieldname">Data starts from row no</span> configuration field specifies the row number from which the actual data begins.
<p>
A given data file may be generated by some clumsy software/workflow which is too lazy to delete irrelevant rows from the dataset.
<br>Temporarily (and without setting precedence of any kind) such deletion is allowed to be done from this interface, namely the <span class="help_content_fieldname">Exclude rows foo</span> field.
<br>The mechanism to specify to-be-excluded rows is in a textual CLI (Command Line Interface) form consisting of three tokens, each separeted by a colon 
<br><span class="freeform_cli_example">COLUMN:COMPARATOR:VALUE</span> 
<br>For example, to exclude all rows from a dataset where column 5 has value 3 one would specify the following text
<br><span class="freeform_cli_example">5:eq:3</span>
<br>The interface also accepts spreadsheet equivalent 'E' (alpha-like) column identifiers, so the equivalent notation for the above example could well be
<br><span class="freeform_cli_example">E:eq:3</span>
<br>The possible comparator options (i.e. text for the middle token) are: 
<ul>
<li><em>lt</em> (less than)</li>
<li><em>le</em> (less than or equal)</li>
<li><em>eq</em> (equal)</li>
<li><em>ne</em> (not equal)</li>
<li><em>ge</em> (greater than or equal)</li>
<li><em>gt</em> (greater than)</li>
</ul>
For example, to delete all rows where second column has values greater than 7 one would enter
<br><span class="freeform_cli_example">b:gt:7</span>
<br>Additionally, a special-meaning wildcard column-specifier may be entered
<br><span class="freeform_cli_example">*:eq:3</span>
<br>resulting in all rows where <em>any attribute</em> has a value of 3 being excluded from computation (i.e. deleted when the dataset is sent to the server for processing).
<br>One is free to specify multilpe tuples separeted by (white)space such as
<br><span class="freeform_cli_example">*:eq:7 AB:lt:4 1:eq:5</span>
<p>Currently the values used to delete rows must only be numbers (i.e. no alpha-numeric values are allowed). This requirement may be relaxed in future, but currently it still stands.
<p>Such a CLI field may be deprecated in future as it may lead to an over-cluttering of the interface with different options/features for a wide variety of different data-producing software packages. This will result in a mess where only a few fields/options are relevant to any given user. Instead, in future, an approach may be adopted where additional utilities are used to prepare the dataset separately from this interface and then being able to upload such a 'federated standard' data file to the server via this interface. The deployment of any given preparation utility will be the responsibilty of the user who had chosen to use whichever lazy/clumsy dataset-producing software in the first place.
<br>Lastly, do take care with respect what you are typing as currently there is a minimal amount of input-error detection!
<p> 
Some data files may not be pre-grouped/ordered by respondent/choice set/alternative columns. Selecting the <span class="help_content_fieldname">Perform sorting of dataset (at the server)</span> option will request the processing server to sort the uploaded .csv file by the aforementioned columns. This may add to the time taken to add a task, so don't tick the checkbox if the supplied dataset is already sorted. Once again, this feature may be deprecated in the near future (instead execting the users to take care of their dataset prior to using this interface).
<p>
<span class="help_content_fieldname">Strip'n'zip dataset before sending to server</span> option allows one to strip irrelevant columns from the .CSV dataset whilst also compressing (zipping) relevant columns -- thereby minimizing the amount of data that is transmitted over the network to the processing server. This option, unfortunately, has to do its foo in pure Javascript on the client-side (i.e. a web-browser does all the stripping and zipping) and consequently it is not the fastest of processes in the whole wild wild west. However what it does provide is, effectively, an opportunity to tune one's workflow: 
<ul>
<li>if one is adding a new task from a computer which is connected to a very slow/expensive network (e.g. 3g broadband SIM card et. al.) then it would make sense to use this option (as uploading huge dataset may take very long time and cost some money)...</li>
<li>alternatively, if one is connected to a very fast network (e.g. organisation's LAN to which the actual server is connected), or if one's dataset is rather small to begin with (due to either already being pre-stripped -selected, or just having a small-enough size altogether), then one would opt to not have the aforementioned option selected.</li>
</ul>
</div>

<div class="help_content" id="help_vcgw_coefficients_metadata_content">
<br>
This is an over-generalized (accuracy sacrificed for the sake of brevity) description. For more details consult the <a href="https://dl.dropbox.com/s/8yqxktfye2mqrnv/VCGW.pdf?token_hash=AAFuPIQ1Zt_vwA4dxAwl2Lswd1XAt4IavbA9AKXQ-oKvbg&dl=1" target="_blank">VCGW paper</a> and then, if even more detail is needed, relevant sections of the <a href="https://github.com/CenSoC/leon_wip" target="_blank">source-code</a> repository.
<p>
Imagining the whole of the problem space as a multidimensional terrain where each coefficient is a dimension and the terrain's elevation is a likelihood-value produced by the chosen computational model, the algorithm may: 
<ol>
<li>Divide each dimension into an evenly-spaced grid of points between the boundaries (<span class="help_content_fieldname">to</span> and <span class="help_content_fieldname">from</span> configuration values). This is the overall exploration constraints of the terrain.</li>
<li>Pick a starting (reference) sampling point -- by randomly selecting a grid-point/coordinate from every dimension/coefficient.</li>
<li>
Evaluate a bunch of <em>different</em> sampling locations (looking for a better likelihood) by changing only <em>one</em> coefficient at a time w.r.t. the starting point:</li>
<ul>
<li>if no better likelihood was found -- consider more sampling points but now by changing <em>two</em> coefficients at a time, and so on (three coefficients at once, four, five, etc.) -- until a certain limit ("complexity size" of <span class="help_content_fieldname">max-coefficients-@once</span>) has been reached</li>
<li>if a better likelihood <em>was</em> found -- walk to the newly found location and make it a new point-of-reference and then repeat the whole process (e.g. starting with "fewer-coefficients-at-once" and progressing to "maximum-allowed-coefficients-at-once" complexity)</li>
</ul>
</li>
<li>
Eventually, even the <span class="help_content_fieldname">max-coefficients-@once</span> (i.e. nominated initial complexity size) will not produce a better likelihood. The algorithm then <em>shrinks</em> it's boundaries around the current point-of-reference and then repeats the whole process from the start (only now with a smaller from/to exploration range due to shrinkage). 
</li>
<li>
Termination criteria is when shrunk boundaries are smaller than a chosen range (i.e. <span class="help_content_fieldname">Consider done @range</span> configuration field). When all of the coefficients are considered done then the whole convergence process is completed.
</li>
</ol>
<p>
As a matter of further computational efficiency the algorithm has an option to use <em>different</em> number of <span class="help_content_fieldname">Gridsteps for x-coefficients-@once modulations</span> (e.g. one may want to lower the number of grid-points when iterating through all possible combinatinos of a max-coefficients-at-once complexity -- this has a price of a coarser resolution but without sacrificing the "multidimensional-diagonality" capability of the exploration process).
<p>
Moreover, as the convergence process zooms in -- one may consider the possibility of terrain becoming <em>smoother</em> (e.g. with lesser traits of multidimensional diagonality). To this extent, the algorithm allows additional (alternative) complexities settings when the zoom-in process crosses certain thresholds. There could be any <span class="help_content_fieldname">Number of additional complexity settings</span>. 
<br>A given additional complexity comes "into effect" when all of the coefficients' exploration ranges are below specified threshold (such threshold is individually-configurable for each of the coefficients via <span class="help_content_fieldname">Activate @range less than</span>).
<div class="freeform_cli_example">
NOTE: given the current lack of proper hardware used to deploy various servers (i.e. my current computer), it is NOT recommended to have any of the
<ul>
<li>complexity-size of <span class="help_content_fieldname">max-coefficients-@once</span> fields to be over 4-coefficients-@once limit </li>
<li>given zoom final complexity size (i.e. total number of "log-likelihood or similar" evaluations in max-coeffs-at-once context) to be over 3000000 or so!  </li>
</ul>
The final complexity sizes are usually printed out when the job is accepted by the server (or you may choose to control/limit it with the <span class="help_content_fieldname">Max. evaluations in any complexity</span> control). More on this will be documented later (if need be)...
</div>
<br>
</div>

<div class="help_content" id="help_vcgw_misc_content">
Other algorithm-configuration values are as follows:
<ul>
<li>
Specifying max-coefficients-@once above may result in an enormous number of likelihood evaluations (e.g. all possible combinations of any 5-coefficients-@once in a 20-coefficients model where each of the coefficients has 10 grid-points may implicitly yield a practically-infeasible amount of sampling points). This, naturally, depends on the underlying deployment infrastructure (how many computers deployed, their power, etc.) but the notion of providing a simple, one-figure control to limit the maximum number of evaluations still stands. 
<br><span class="help_content_fieldname">Max. evaluations in any complexity</span> is such a control. If a given complexity setting yields total number of evaluations higher than in this field, the number of max-coefficients-@once will be reduced.
</li>
<li>
<span class="help_content_fieldname">Number of draws</span> is the number of 'random' draws performed when calculating model's variance and/or scale distributions. In reality, the draws are not purely random... nor are they from a <a href="http://en.wikipedia.org/wiki/Halton_sequence" target="_blank">Halton sequence</a>. Instead a somewhat optimized approach to obtain even-coverage, yet uncorrelated progression, is used. Basically, in comparison to a Halton sequence, there is one more additional bit of information that can be leveraged in the convergence process: a priory-known number of draws. So the process is to create a set of evenly-distributed grid points, then randomly-shuffle it's contents. This is not 100% correct but more concise than a full <a href="https://github.com/CenSoC/leon_wip" target="_blank">source-code</a> listing).
</li>
<li>
<span class="help_content_fieldname">Number of drawn sets</span> allows for some (or all) of the respondents to have <em>redrawn</em> values from the underlying distributions. The other fileld ("Number of draws") is used to generate <em>one set</em> of distributed numbers (i.e. explicit draws for each of the attributes' variances and the scaling distributions) -- for calculating <em>given</em> respondent's likelihood. If there is more than one set, different respondents will use different sets. The process is to loop-through/iterate the available sets whenever moving onto the next respondent's data. If there are less sets than respondents then some respondents will use the same set(s). Care must be taken when using large values in this field -- as invariably this shall cause larger memory requirements on every of the processing computers.
</li>
<li>
<span class="help_content_fieldname">Zoom-in slowdown</span> an arbitrary control to slow-down the shrinkage (zooming-in). The values of zero means no slowdown (implying the new range will be made from two grid-points around the reference-point), the value of one is full slowdown.
</li>
<li>
Some sampling points' likelihood calculations may result in values which are better than that of the reference-point but only by an "insignificant" amount. Such events can cause overly-frequent walking-and-resetting of the algorithm without yielding much improvement. 
<span class="help_content_fieldname">Min. improvement ratio</span> 
allows one to prevent the algorithm walking to the newly-found better likelihood coordinates if such a better value is below the ratio with respect to the currently-established point of reference. Explicit calculation is that P<sub>new</sub> / P<sub>old</sub> has to be &gt 
<span class="help_content_fieldname">Min. improvement ratio</span>.
<br><em>Note</em>:  the above description is not quite correct actually... Given that in reality most calculations are <em>log</em>-likelihood values, it would have been better to simply take a difference (not ratio) between the old and the new values... alas, for historical reasons, the ratio mechanism remains as is. It will be fixed later on. In the meantime it is an arbitrary value anyways, so something close to 1 should do.
</li>
<li>
Some surveys may require extremely small (close to, but not quite, zero) or large values to be supported during the computation of likelihood (e.g. due to large number of respondents, large number of choice-observations, extreme boundaries of the exploration range for various coefficients, or simply the nature of the model's equation). On the other hand, other surveys may not need such an extreme-numbers support. The support for larger-range values comes at a price of slower calculations. The algorithm therefore allows one to specify the floating-point resolution for the model's calculations (e.g. 32-bit IEEE 'single' float resolution may provide much faster results). There are two controls for fine-tuning the aforementioned range-support:
<ul>
<li>
The <span class="help_content_fieldname">Floating-point res</span> denotes resolution for the majority of real-number calculations (e.g. distribution draws, etc.) as well as the coefficient values, etc. 
</li>
<li>
The <span class="help_content_fieldname">Extended floating-point res</span> is for sub-section of the model's calculations such as exponents and subsequent calculations using possibly extreme-range values.
</li>
</ul>
</li>
<li>
<span class="help_content_fieldname">Integer/memory-size res</span> is similar to the floating-point resolution fields. It only applies to the integral aspects of task processing (count of draws, number of respondents, total number of rows in a dataset, total memory used by the model, etc.) 32-bit numbers can deal with figures under a 4 billion (4Gigabytes of memory) mark and so should be sufficient for many surveys. On the other hand, if one has a huge survey which in total (e.g. respondents * choices * alternatives * draws * 10 etc. is &lt 4 billion) then 64-bit integers can be chosen (at a price of a somewhat larger memory usage and slower(ish) execution).
</li>
<li>
<span class="help_content_fieldname">Approximate exponents</span> allows one to use an oversamlped, linearly-interpolated approximation of the exponents. In other words, instead of evaluating '::std::exp(x)' or other similar math library routines everytime an exponent value is needed, a pre-sampled table of exponents is made (with input values separated by small steps-size) and then such a table is linearly interpolated depending on where the given 'x' value is positioned with respect to the pre-sampled steps. A number of empirical tests had shown no tangible/differentiating-practical-outcome changes as compared to the non-approximating option. The approximation option, however, may show improvements in computational speed. Given that any successful convergence process will invariably involve multiple <em>completed</em> convergence runs it is envisaged that the option may indeed be delpoyed in a time-saving fashion. 
</li>
</ul>
</div>
<div class="help_content" id="help_short_description_content">
This field requires one, in the spirit of being a good citizen, to provide a short description/tag of the project (e.g. "carbon pro. for Jordan"). This allows others to better determine whether they want to "jump the queue" potentially pausing/delaying computation of other active/pending tasks. This field is <em>not</em> a replacement for proactive note-taking -keeping by the user. The user is expected to keep a <em>concurrent</em> set of notes relating to the processed task (why the task is created, what dataset is being used and why, what project the whole thing belongs to, etc). The process, therefore, is as follows: after adding a new task, <em>DO</em> take note of (i.e. write down) the returned task-id and use it in your records/notes; upon task's completion add to the relevant notes the resulting coefficients values et. al.; use the notes in your research.
</div>
<div id="visible_dims" style="width:100%;height:100%;position:fixed;left:0;top:0;visibility:hidden;z-index:-1"></div>
</body>
</html>
<!-- } -->
